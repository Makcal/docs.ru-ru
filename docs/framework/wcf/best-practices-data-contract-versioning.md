---
description: 'Дополнительные сведения: рекомендации по управлению версиями контракта данных'
title: Рекомендации. Управление версиями контракта данных
ms.date: 03/30/2017
helpviewer_keywords:
- data contracts
- service contracts
- best practices [WCF], data contract versioning
- Windows Communication Foundation, data contracts
ms.assetid: bf0ab338-4d36-4e12-8002-8ebfdeb346cb
ms.openlocfilehash: 8f12c620b6916c7b513b3491cbbb91c4cfd1fbe5
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99686756"
---
# <a name="best-practices-data-contract-versioning"></a><span data-ttu-id="731a0-103">Рекомендации. Управление версиями контракта данных</span><span class="sxs-lookup"><span data-stu-id="731a0-103">Best Practices: Data Contract Versioning</span></span>

<span data-ttu-id="731a0-104">В данном разделе приводятся рекомендации по созданию контрактов данных, которые можно легко развить со временем.</span><span class="sxs-lookup"><span data-stu-id="731a0-104">This topic lists the best practices for creating data contracts that can evolve easily over time.</span></span> <span data-ttu-id="731a0-105">Дополнительные сведения о контрактах данных см. в разделах, посвященных [использованию контрактов данных](./feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-105">For more information about data contracts, see the topics in [Using Data Contracts](./feature-details/using-data-contracts.md).</span></span>  
  
## <a name="note-on-schema-validation"></a><span data-ttu-id="731a0-106">Замечания по проверке схемы</span><span class="sxs-lookup"><span data-stu-id="731a0-106">Note on Schema Validation</span></span>  

 <span data-ttu-id="731a0-107">При обсуждении управления версиями контракта данных важно отметить, что схема контракта данных, экспортированная Windows Communication Foundation (WCF), не поддерживает управление версиями, Кроме того, что элементы помечаются как необязательные по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="731a0-107">In discussing data contract versioning, it is important to note that the data contract schema exported by Windows Communication Foundation (WCF) does not have any versioning support, other than the fact that elements are marked as optional by default.</span></span>  
  
 <span data-ttu-id="731a0-108">Это значит, что даже самые общие сценарии управления версиями, такие как добавление нового члена данных, невозможно реализовать так, чтобы обеспечить тесное взаимодействие с данной схемой.</span><span class="sxs-lookup"><span data-stu-id="731a0-108">This means that even the most common versioning scenario, such as adding a new data member, cannot be implemented in a way that is seamless with regard to a given schema.</span></span> <span data-ttu-id="731a0-109">Новые версии контракта данных (например, с новым членом данных) не выполняют проверку с использованием старой схемы.</span><span class="sxs-lookup"><span data-stu-id="731a0-109">The newer versions of a data contract (with a new data member, for example) do not validate using the old schema.</span></span>  
  
 <span data-ttu-id="731a0-110">Однако существует много сценариев, в которых не требуется строгое соответствие схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-110">However, there are many scenarios in which strict schema compliance is not required.</span></span> <span data-ttu-id="731a0-111">Многие платформы веб-служб, включая WCF и веб-службы XML, созданные с помощью ASP.NET, не выполняют проверку схемы по умолчанию и, таким образом, допускают дополнительные элементы, не описанные в схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-111">Many Web services platforms, including WCF and XML Web services created using ASP.NET, do not perform schema validation by default and therefore tolerate extra elements that are not described by the schema.</span></span> <span data-ttu-id="731a0-112">При работе с такими платформами множество сценариев управления версиями легче реализовать.</span><span class="sxs-lookup"><span data-stu-id="731a0-112">When working with such platforms, many versioning scenarios are easier to implement.</span></span>  
  
 <span data-ttu-id="731a0-113">Таким образом, предусмотрено два набора рекомендаций по управлению версиями контрактов данных: один набор для сценариев, в которых строгое соответствие схеме необходимо, и второй набор для сценариев, в которых нет необходимости в строгом соответствии схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-113">Thus, there are two sets of data contract versioning guidelines: one set for scenarios where strict schema validity is important, and another set for scenarios when it is not.</span></span>  
  
## <a name="versioning-when-schema-validation-is-required"></a><span data-ttu-id="731a0-114">Управление версиями при необходимости в проверке схемы</span><span class="sxs-lookup"><span data-stu-id="731a0-114">Versioning When Schema Validation Is Required</span></span>  

 <span data-ttu-id="731a0-115">Если строгое соответствие схеме является обязательным требованием во всех направлениях (от новой версии к старой и от старой версии к новой), контракты данных следует считать неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="731a0-115">If strict schema validity is required in all directions (new-to-old and old-to-new), data contracts should be considered immutable.</span></span> <span data-ttu-id="731a0-116">При необходимости в управлении версиями следует создать новый контракт данных с другим именем или пространством имен, и управление версиями контракта службы, использующего тип данных, должно осуществляться соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="731a0-116">If versioning is required, a new data contract should be created, with a different name or namespace, and the service contract using the data type should be versioned accordingly.</span></span>  
  
 <span data-ttu-id="731a0-117">Например, контракт службы обработки заказов на поставку с именем `PoProcessing` и операцией `PostPurchaseOrder` принимает параметр, соответствующий контракту данных `PurchaseOrder`.</span><span class="sxs-lookup"><span data-stu-id="731a0-117">For example, a purchase order processing service contract named `PoProcessing` with a `PostPurchaseOrder` operation takes a parameter that conforms to a `PurchaseOrder` data contract.</span></span> <span data-ttu-id="731a0-118">Если необходимо изменить контракт `PurchaseOrder`, следует создать новый контракт данных, т. е. `PurchaseOrder2`, с внесенными изменениями.</span><span class="sxs-lookup"><span data-stu-id="731a0-118">If the `PurchaseOrder` contract has to change, you must create a new data contract, that is, `PurchaseOrder2`, which includes the changes.</span></span> <span data-ttu-id="731a0-119">Затем необходимо выполнить управление версиями на уровне контракта службы.</span><span class="sxs-lookup"><span data-stu-id="731a0-119">You must then handle the versioning at the service contract level.</span></span> <span data-ttu-id="731a0-120">Например, создайте операцию `PostPurchaseOrder2`, принимающую параметр `PurchaseOrder2`, или создайте контракт службы `PoProcessing2`, в котором операция `PostPurchaseOrder` принимает контракт данных `PurchaseOrder2`.</span><span class="sxs-lookup"><span data-stu-id="731a0-120">For example, by creating a `PostPurchaseOrder2` operation that takes the `PurchaseOrder2` parameter, or by creating a `PoProcessing2` service contract where the `PostPurchaseOrder` operation takes a `PurchaseOrder2` data contract.</span></span>  
  
 <span data-ttu-id="731a0-121">Обратите внимание, что изменения в контрактах данных, на которые ссылаются другие контракты данных, также расширяются до уровня модели службы.</span><span class="sxs-lookup"><span data-stu-id="731a0-121">Note that changes in data contracts that are referenced by other data contracts also extend to the service model layer.</span></span> <span data-ttu-id="731a0-122">Например, в предыдущем сценарии контракт данных `PurchaseOrder` изменять не требуется.</span><span class="sxs-lookup"><span data-stu-id="731a0-122">For example, in the previous scenario the `PurchaseOrder` data contract does not need to change.</span></span> <span data-ttu-id="731a0-123">Однако он содержит член данных контракта данных `Customer`, который, в свою очередь, содержал член данных контракта данных `Address`, который не требуется изменять.</span><span class="sxs-lookup"><span data-stu-id="731a0-123">However, it contains a data member of a `Customer` data contract, which in turn contained a data member of the `Address` data contract, which does need to be changed.</span></span> <span data-ttu-id="731a0-124">В этом случае необходимо создать контракт данных `Address2` с требуемыми изменениями, контракт данных `Customer2`, содержащий член данных `Address2`, и контракт данных `PurchaseOrder2`, содержащий член данных `Customer2`.</span><span class="sxs-lookup"><span data-stu-id="731a0-124">In that case, you would need to create an `Address2` data contract with the required changes, a `Customer2` data contract that contains the `Address2` data member, and a `PurchaseOrder2` data contract that contains a `Customer2` data member.</span></span> <span data-ttu-id="731a0-125">Как и в предыдущем случае, также следует осуществить управление версиями контракта службы.</span><span class="sxs-lookup"><span data-stu-id="731a0-125">As in the previous case, the service contract would have to be versioned as well.</span></span>  
  
 <span data-ttu-id="731a0-126">Несмотря на то что в этих примерах имена изменены (добавлена цифра "2"), рекомендуется изменять пространства имен вместо имен путем добавления новых пространств имен с номером или датой версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-126">Although in these examples names are changed (by appending a "2"), the recommendation is to change namespaces instead of names by appending new namespaces with a version number or a date.</span></span> <span data-ttu-id="731a0-127">Например, контракт данных `http://schemas.contoso.com/2005/05/21/PurchaseOrder` изменится на контракт данных `http://schemas.contoso.com/2005/10/14/PurchaseOrder`.</span><span class="sxs-lookup"><span data-stu-id="731a0-127">For example, the `http://schemas.contoso.com/2005/05/21/PurchaseOrder` data contract would change to the `http://schemas.contoso.com/2005/10/14/PurchaseOrder` data contract.</span></span>  
  
 <span data-ttu-id="731a0-128">Дополнительные сведения см. в разделе рекомендации по управлению [версиями служб](service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-128">For more information, see Best Practices: [Service Versioning](service-versioning.md).</span></span>  
  
 <span data-ttu-id="731a0-129">Иногда необходимо обеспечить строгое соответствие схеме для сообщений, отправляемых приложением, но нельзя полагаться на то, что входящие сообщения строго соответствуют схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-129">Occasionally, you must guarantee strict schema compliance for messages sent by your application, but cannot rely on the incoming messages to be strictly schema-compliant.</span></span> <span data-ttu-id="731a0-130">В это случае существует опасность того, что входящее сообщение может содержать лишние данные.</span><span class="sxs-lookup"><span data-stu-id="731a0-130">In this case, there is a danger that an incoming message might contain extraneous data.</span></span> <span data-ttu-id="731a0-131">Излишние значения хранятся и возвращаются WCF, что приводит к отправке недопустимых сообщений в схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-131">The extraneous values are stored and returned by WCF and thus results in schema-invalid messages being sent.</span></span> <span data-ttu-id="731a0-132">Чтобы избежать этой проблемы, необходимо выключить возможность полной совместимости версий.</span><span class="sxs-lookup"><span data-stu-id="731a0-132">To avoid this problem, the round-tripping feature should be turned off.</span></span> <span data-ttu-id="731a0-133">Это можно сделать двумя способами.</span><span class="sxs-lookup"><span data-stu-id="731a0-133">There are two ways to do this.</span></span>  
  
- <span data-ttu-id="731a0-134">Не реализуйте интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject> ни в одном из своих типов.</span><span class="sxs-lookup"><span data-stu-id="731a0-134">Do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface on any of your types.</span></span>  
  
- <span data-ttu-id="731a0-135">Примените атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute> к своему контракту службы, в котором свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> присвоено значение `true`.</span><span class="sxs-lookup"><span data-stu-id="731a0-135">Apply a <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to your service contract with the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property set to `true`.</span></span>  
  
 <span data-ttu-id="731a0-136">Дополнительные сведения о циклической активации см. в разделе [контракты данных с прямыми совместимостью](./feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-136">For more information about round-tripping, see [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md).</span></span>  
  
## <a name="versioning-when-schema-validation-is-not-required"></a><span data-ttu-id="731a0-137">Управление версиями при отсутствии необходимости в проверке схемы</span><span class="sxs-lookup"><span data-stu-id="731a0-137">Versioning When Schema Validation Is Not Required</span></span>  

 <span data-ttu-id="731a0-138">Строгое соответствие схеме требуется редко.</span><span class="sxs-lookup"><span data-stu-id="731a0-138">Strict schema compliance is rarely required.</span></span> <span data-ttu-id="731a0-139">Множество платформ допускают наличие дополнительных элементов, не описанных в схеме.</span><span class="sxs-lookup"><span data-stu-id="731a0-139">Many platforms tolerate extra elements not described by a schema.</span></span> <span data-ttu-id="731a0-140">Пока это допускается, можно использовать полный набор функций, описанных в разделе [Управление версиями контракта данных](./feature-details/data-contract-versioning.md) и [контракты данных с прямыми совместимостью](./feature-details/forward-compatible-data-contracts.md) .</span><span class="sxs-lookup"><span data-stu-id="731a0-140">As long as this is tolerated, the full set of features described in [Data Contract Versioning](./feature-details/data-contract-versioning.md) and [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md) can be used.</span></span> <span data-ttu-id="731a0-141">Рекомендуется соблюдать следующее.</span><span class="sxs-lookup"><span data-stu-id="731a0-141">The following guidelines are recommended.</span></span>  
  
 <span data-ttu-id="731a0-142">Некоторые рекомендации необходимо соблюдать строго, чтобы отправлять новые версии типа, если ожидается старая версия, или отправлять старую версию, если ожидается новая версия.</span><span class="sxs-lookup"><span data-stu-id="731a0-142">Some of the guidelines must be followed exactly in order to send new versions of a type where an older one is expected or send an old one where the new one is expected.</span></span> <span data-ttu-id="731a0-143">Другие рекомендации не обязательно соблюдать строго, но они перечислены ниже, поскольку на них может повлиять будущее управление версиями схемы.</span><span class="sxs-lookup"><span data-stu-id="731a0-143">Other guidelines are not strictly required, but are listed here because they may be affected by the future of schema versioning.</span></span>  
  
1. <span data-ttu-id="731a0-144">Не пытайтесь управлять версиями контрактов данных с использованием наследования типов.</span><span class="sxs-lookup"><span data-stu-id="731a0-144">Do not attempt to version data contracts by type inheritance.</span></span> <span data-ttu-id="731a0-145">Чтобы создать более поздние версии, либо измените контракт данных в существуем типе, либо создайте новый несвязанный тип.</span><span class="sxs-lookup"><span data-stu-id="731a0-145">To create later versions, either change the data contract on an existing type or create a new unrelated type.</span></span>  
  
2. <span data-ttu-id="731a0-146">Использование наследования вместе с контрактами данных допускается, если наследование не используется как механизм управления версиями и выполняются определенные правила.</span><span class="sxs-lookup"><span data-stu-id="731a0-146">The use of inheritance together with data contracts is allowed, provided that inheritance is not used as a versioning mechanism and that certain rules are followed.</span></span> <span data-ttu-id="731a0-147">Если тип наследуется от определенного базового типа, он не должен наследоваться от другого базового типа в будущей версии (за исключением случаев, когда у них одинаковые контракты данных).</span><span class="sxs-lookup"><span data-stu-id="731a0-147">If a type derives from a certain base type, do not make it derive from a different base type in a future version (unless it has the same data contract).</span></span> <span data-ttu-id="731a0-148">Существует одно исключение из этого: можно вставить тип в иерархию между типом контракта данных и его базовым типом, но только если в нем не содержится членов данных с такими же именами, как у других членов в любых возможных версиях других типов в иерархии.</span><span class="sxs-lookup"><span data-stu-id="731a0-148">There is one exception to this: you can insert a type into the hierarchy between a data contract type and its base type, but only if it does not contain data members with the same names as other members in any possible versions of the other types in the hierarchy.</span></span> <span data-ttu-id="731a0-149">Как правило, использование членов данных с одинаковыми именами на разных уровнях одной и той же иерархии наследования может привести к серьезным проблемам с управлением версиями. Этого следует избегать.</span><span class="sxs-lookup"><span data-stu-id="731a0-149">In general, using data members with the same names at different levels of the same inheritance hierarchy can lead to serious versioning problems and should be avoided.</span></span>  
  
3. <span data-ttu-id="731a0-150">Начиная с первой версии контракта данных, всегда реализуйте <xref:System.Runtime.Serialization.IExtensibleDataObject> для включения полной совместимости версий.</span><span class="sxs-lookup"><span data-stu-id="731a0-150">Starting with the first version of a data contract, always implement <xref:System.Runtime.Serialization.IExtensibleDataObject> to enable round-tripping.</span></span> <span data-ttu-id="731a0-151">Дополнительные сведения о создании контрактов данных, обладающих прямой совместимостью, см. в разделе [Контракты данных, совместимые с любыми будущими изменениями](./feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-151">For more information, see [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="731a0-152">Если имеется одна или несколько версий типа без реализации этого интерфейса, реализуйте его в следующей версии типа.</span><span class="sxs-lookup"><span data-stu-id="731a0-152">If you have released one or more versions of a type without implementing this interface, implement it in the next version of the type.</span></span>  
  
4. <span data-ttu-id="731a0-153">В более поздних версиях не изменяйте имя или пространство имен контракта данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-153">In later versions, do not change the data contract name or namespace.</span></span> <span data-ttu-id="731a0-154">При изменении имени или пространства имен базового типа контракта данных обязательно сохраните имя и пространство имен контракта данных с помощью соответствующих механизмов, таких как свойство <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> атрибута <xref:System.Runtime.Serialization.DataContractAttribute>.</span><span class="sxs-lookup"><span data-stu-id="731a0-154">If changing the name or namespace of the type underlying the data contract, be sure to preserve the data contract name and namespace by using the appropriate mechanisms, such as the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>.</span></span> <span data-ttu-id="731a0-155">Дополнительные сведения об именовании см. в разделе [имена контрактов данных](./feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-155">For more information about naming, see [Data Contract Names](./feature-details/data-contract-names.md).</span></span>  
  
5. <span data-ttu-id="731a0-156">В более поздних версиях не изменяйте имена членов данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-156">In later versions, do not change the names of any data members.</span></span> <span data-ttu-id="731a0-157">При изменении имени поля, свойства или базового события члена данных используйте свойство `Name` атрибута <xref:System.Runtime.Serialization.DataMemberAttribute>, чтобы сохранить существующее имя члена данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-157">If changing the name of the field, property, or event underlying the data member, use the `Name` property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to preserve the existing data member name.</span></span>  
  
6. <span data-ttu-id="731a0-158">В более поздних версиях не изменяйте тип поля, свойства или базового события члена данных, чтобы не изменился итоговый контракт данных для члена данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-158">In later versions, do not change the type of any field, property, or event underlying a data member such that the resulting data contract for that data member changes.</span></span> <span data-ttu-id="731a0-159">Необходимо помнить, что типы интерфейсов эквивалентны классу <xref:System.Object>, при определении ожидаемого контракта данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-159">Keep in mind that interface types are equivalent to <xref:System.Object> for the purposes of determining the expected data contract.</span></span>  
  
7. <span data-ttu-id="731a0-160">В более поздних версиях не изменяйте порядок существующих членов данных путем изменения свойства <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> атрибута <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="731a0-160">In later versions, do not change the order of the existing data members by adjusting the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute.</span></span>  
  
8. <span data-ttu-id="731a0-161">В более поздних версиях можно добавлять новые члены данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-161">In later versions, new data members can be added.</span></span> <span data-ttu-id="731a0-162">Они всегда должны соответствовать следующим правилам.</span><span class="sxs-lookup"><span data-stu-id="731a0-162">They should always follow these rules:</span></span>  
  
    1. <span data-ttu-id="731a0-163">Для свойства <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> всегда следует сохранять значение по умолчанию `false`.</span><span class="sxs-lookup"><span data-stu-id="731a0-163">The <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property should always be left at its default value of `false`.</span></span>  
  
    2. <span data-ttu-id="731a0-164">Если значение по умолчанию `null` или нуль для члена неприемлемо, то необходимо предусмотреть метод обратного вызова с использованием <xref:System.Runtime.Serialization.OnDeserializingAttribute> для обеспечения разумного значения по умолчанию при отсутствии члена во входящем потоке.</span><span class="sxs-lookup"><span data-stu-id="731a0-164">If a default value of `null` or zero for the member is unacceptable, a callback method should be provided using the <xref:System.Runtime.Serialization.OnDeserializingAttribute> to provide a reasonable default in case the member is not present in the incoming stream.</span></span> <span data-ttu-id="731a0-165">Дополнительные сведения о обратном вызове см. в разделе [обратные вызовы сериализации, зависящие от версии](./feature-details/version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-165">For more information about the callback, see [Version-Tolerant Serialization Callbacks](./feature-details/version-tolerant-serialization-callbacks.md).</span></span>  
  
    3. <span data-ttu-id="731a0-166"><xref:System.Runtime.Serialization.DataMemberAttribute.Order?displayProperty=nameWithType>Свойство следует использовать, чтобы убедиться, что все вновь добавленные элементы данных отображаются после существующих элементов данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-166">The <xref:System.Runtime.Serialization.DataMemberAttribute.Order?displayProperty=nameWithType> property should be used to make sure that all of the newly added data members appear after the existing data members.</span></span> <span data-ttu-id="731a0-167">Рекомендуемый способ выполнения этого заключается в следующем: значение свойству `Order` не должно быть присвоено ни для одного члена данных в первой версии контракта данных.</span><span class="sxs-lookup"><span data-stu-id="731a0-167">The recommended way of doing this is as follows: None of the data members in the first version of the data contract should have their `Order` property set.</span></span> <span data-ttu-id="731a0-168">Для всех элементов данных, добавленных в версии 2 контракта данных, свойство `Order` должно иметь значение 2.</span><span class="sxs-lookup"><span data-stu-id="731a0-168">All of the data members added in version 2 of the data contract should have their `Order` property set to 2.</span></span> <span data-ttu-id="731a0-169">Для всех элементов данных, добавленных в версии 3 контракта данных, свойство `Order` должно иметь значение 3 и так далее</span><span class="sxs-lookup"><span data-stu-id="731a0-169">All of the data members added in version 3 of the data contract should have their `Order` set to 3, and so on.</span></span> <span data-ttu-id="731a0-170">Допускается задание нескольких членов данных одному номеру свойства `Order`.</span><span class="sxs-lookup"><span data-stu-id="731a0-170">It is permissible to have more than one data member set to the same `Order` number.</span></span>  
  
9. <span data-ttu-id="731a0-171">Не удаляйте члены данных в более поздних версиях, даже если для свойства <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> сохранено значение по умолчанию `false` в предыдущих версиях.</span><span class="sxs-lookup"><span data-stu-id="731a0-171">Do not remove data members in later versions, even if the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property was left at its default property of `false` in prior versions.</span></span>  
  
10. <span data-ttu-id="731a0-172">Не изменяйте свойство `IsRequired` существующих членов данных от версии к версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-172">Do not change the `IsRequired` property on any existing data members from version to version.</span></span>  
  
11. <span data-ttu-id="731a0-173">Для требуемых членов данных (свойству `IsRequired` присвоено значение `true`) не изменяйте свойство `EmitDefaultValue` от версии к версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-173">For required data members (where `IsRequired` is `true`), do not change the `EmitDefaultValue` property from version to version.</span></span>  
  
12. <span data-ttu-id="731a0-174">Не пытайтесь создать ответвления иерархий управления версиями.</span><span class="sxs-lookup"><span data-stu-id="731a0-174">Do not attempt to create branched versioning hierarchies.</span></span> <span data-ttu-id="731a0-175">Это значит, что всегда должен указываться путь, по крайней мере, в одном направлении от версии к версии, с использованием только тех изменений, которые допускаются этими правилами.</span><span class="sxs-lookup"><span data-stu-id="731a0-175">That is, there should always be a path in at least one direction from any version to any other version using only the changes permitted by these guidelines.</span></span>  
  
     <span data-ttu-id="731a0-176">Например, если в версии 1 контракта данных "Person" содержится только член данных "Name", не следует создавать версию 2a контракта, добавляя только член "Age", и версию 2b, добавляя только член "Address".</span><span class="sxs-lookup"><span data-stu-id="731a0-176">For example, if version 1 of a Person data contract contains only the Name data member, you should not create version 2a of the contract adding only the Age member and version 2b adding only the Address member.</span></span> <span data-ttu-id="731a0-177">Переход от версии 2a к версии 2b будет включать в себя удаление члена "Age" и добавление члена "Address". Переход в другом направлении повлечет за собой удаление члена "Address" и добавление члена"Age".</span><span class="sxs-lookup"><span data-stu-id="731a0-177">Going from 2a to 2b would involve removing Age and adding Address; going in the other direction would entail removing Address and adding Age.</span></span> <span data-ttu-id="731a0-178">Согласно этим правилам, удалять члены запрещается.</span><span class="sxs-lookup"><span data-stu-id="731a0-178">Removing members is not permitted by these guidelines.</span></span>  
  
13. <span data-ttu-id="731a0-179">Обычно не следует создавать новые подтипы существующих типов контрактов данных в новой версии приложения.</span><span class="sxs-lookup"><span data-stu-id="731a0-179">You should generally not create new subtypes of existing data contract types in a new version of your application.</span></span> <span data-ttu-id="731a0-180">Аналогично, не следует создавать новые контракты данных, используемые вместо членов данных, объявленных как "Object" или как типы интерфейса.</span><span class="sxs-lookup"><span data-stu-id="731a0-180">Likewise, you should not create new data contracts that are used in place of data members declared as Object or as interface types.</span></span> <span data-ttu-id="731a0-181">Создание таких новых классов допускается, только если известно, что можно добавить новые типы в список известных типов всех экземпляров старого приложения.</span><span class="sxs-lookup"><span data-stu-id="731a0-181">Creating these new classes is allowed only when you know that you can add the new types to the known types list of all instances of your old application.</span></span> <span data-ttu-id="731a0-182">Например, в версии 1 приложения имеется тип контракта данных "LibraryItem" с подтипами контракта данных "Book" и "Newspaper".</span><span class="sxs-lookup"><span data-stu-id="731a0-182">For example, in version 1 of your application, you may have the LibraryItem data contract type with the Book and Newspaper data contract subtypes.</span></span> <span data-ttu-id="731a0-183">Тип "LibraryItem" будет иметь список известных типов, содержащий подтипы "Book" и "Newspaper".</span><span class="sxs-lookup"><span data-stu-id="731a0-183">LibraryItem would then have a known types list that contains Book and Newspaper.</span></span> <span data-ttu-id="731a0-184">Предположим, в версию 2 добавляется тип "Magazine", являющийся подтипом типа "LibraryItem".</span><span class="sxs-lookup"><span data-stu-id="731a0-184">Suppose you now add a Magazine type in version 2 which is a subtype of LibraryItem.</span></span> <span data-ttu-id="731a0-185">При отправке экземпляра "Magazine" от версии 2 к версии 1 контракт данных "Magazine" невозможно найти в списке известных типов, и вызывается исключение.</span><span class="sxs-lookup"><span data-stu-id="731a0-185">If you send a Magazine instance from version 2 to version 1, the Magazine data contract is not found in the list of known types and an exception is thrown.</span></span>  
  
14. <span data-ttu-id="731a0-186">Не следует добавлять или удалять члены перечисления от версии к версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-186">You should not add or remove enumeration members between versions.</span></span> <span data-ttu-id="731a0-187">Также не следует переименовывать члены перечисления, если не используется свойство "Name" атрибута `EnumMemberAttribute`, чтобы сохранить имена в модели контракта данных неизменными.</span><span class="sxs-lookup"><span data-stu-id="731a0-187">You should also not rename enumeration members, unless you use the Name property on the `EnumMemberAttribute` attribute to keep their names in the data contract model the same.</span></span>  
  
15. <span data-ttu-id="731a0-188">Коллекции являются взаимозаменяемыми в модели контрактов данных, как описано в разделе [типы коллекций в контрактах данных](./feature-details/collection-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="731a0-188">Collections are interchangeable in the data contract model as described in [Collection Types in Data Contracts](./feature-details/collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="731a0-189">Это повышает степень гибкости.</span><span class="sxs-lookup"><span data-stu-id="731a0-189">This allows for a great degree of flexibility.</span></span> <span data-ttu-id="731a0-190">Однако убедитесь, что тип коллекции случайно не изменен невзаимоизменяемым способом от версии к версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-190">However, make sure that you do not inadvertently change a collection type in a non-interchangeable way from version to version.</span></span> <span data-ttu-id="731a0-191">Например, не изменяйте ненастроенную коллекцию (т. е. без атрибута `CollectionDataContractAttribute`) на настроенную или настроенную коллекцию на ненастроенную.</span><span class="sxs-lookup"><span data-stu-id="731a0-191">For example, do not change from a non-customized collection (that is, without the `CollectionDataContractAttribute` attribute) to a customized one or a customized collection to a non-customized one.</span></span> <span data-ttu-id="731a0-192">Кроме того, не изменяйте свойства атрибута `CollectionDataContractAttribute` от версии к версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-192">Also, do not change the properties on the `CollectionDataContractAttribute` from version to version.</span></span> <span data-ttu-id="731a0-193">Единственным допустимым изменением является добавление свойства "Name" или "Namespace", если имя или пространство имен типа базовой коллекции были изменены, и необходимо, чтобы имя и пространство имен контракта данных были теми же, что и в предыдущей версии.</span><span class="sxs-lookup"><span data-stu-id="731a0-193">The only allowed change is adding a Name or Namespace property if the underlying collection type's name or namespace has changed and you need to make its data contract name and namespace the same as in a previous version.</span></span>  
  
 <span data-ttu-id="731a0-194">В особых обстоятельствах некоторые правила, указанные в данном разделе, можно проигнорировать.</span><span class="sxs-lookup"><span data-stu-id="731a0-194">Some of the guidelines listed here can be safely ignored when special circumstances apply.</span></span> <span data-ttu-id="731a0-195">Убедитесь, что полностью понимаете принципы работы механизмов сериализации, десериализации и схемы перед тем, как уклониться от выполнения правил.</span><span class="sxs-lookup"><span data-stu-id="731a0-195">Make sure you fully understand the serialization, deserialization, and schema mechanisms involved before deviating from the guidelines.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="731a0-196">См. также</span><span class="sxs-lookup"><span data-stu-id="731a0-196">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.ServiceModel.ServiceBehaviorAttribute>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.OnDeserializingAttribute>
- [<span data-ttu-id="731a0-197">Использование контрактов данных</span><span class="sxs-lookup"><span data-stu-id="731a0-197">Using Data Contracts</span></span>](./feature-details/using-data-contracts.md)
- [<span data-ttu-id="731a0-198">Управление версиями контракта данных</span><span class="sxs-lookup"><span data-stu-id="731a0-198">Data Contract Versioning</span></span>](./feature-details/data-contract-versioning.md)
- [<span data-ttu-id="731a0-199">Имена контрактов данных</span><span class="sxs-lookup"><span data-stu-id="731a0-199">Data Contract Names</span></span>](./feature-details/data-contract-names.md)
- [<span data-ttu-id="731a0-200">Контракты данных, совместимые с любыми будущими изменениями</span><span class="sxs-lookup"><span data-stu-id="731a0-200">Forward-Compatible Data Contracts</span></span>](./feature-details/forward-compatible-data-contracts.md)
- [<span data-ttu-id="731a0-201">Обратные вызовы сериализации, независимые от версий</span><span class="sxs-lookup"><span data-stu-id="731a0-201">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
