---
description: 'Дополнительные сведения: сопоставление JSON и XML'
title: Сопоставление JSON и XML.
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: 1d9652d1683446da9946987a31a92906d5e38e55
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793679"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="65b27-103">Сопоставление JSON и XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-103">Mapping Between JSON and XML</span></span>

<span data-ttu-id="65b27-104">Модули чтения и записи, создаваемые фабрикой <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>, обеспечивают интерфейс API XML к содержимому в формате JavaScript Object Notation (JSON, объектной нотации JavaScript).</span><span class="sxs-lookup"><span data-stu-id="65b27-104">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="65b27-105">Формат JSON предусматривает кодирование данных с использованием подмножества объектных литералов JavaScript.</span><span class="sxs-lookup"><span data-stu-id="65b27-105">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="65b27-106">Читатели и модули записи, созданные этой фабрикой, также используются при отправке или получении содержимого JSON приложениями Windows Communication Foundation (WCF) с помощью <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> или <xref:System.ServiceModel.WebHttpBinding> .</span><span class="sxs-lookup"><span data-stu-id="65b27-106">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>

<span data-ttu-id="65b27-107">Модуль чтения JSON при инициализации JSON-содержимым ведет себя так же, как модуль чтения текстовых XML-данных при инициализации экземпляром XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-107">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="65b27-108">Модуль записи JSON при получении последовательности вызовов, в результате которой модуль чтения текстовых XML-данных создает определенный экземпляр XML, записывает JSON-содержимое.</span><span class="sxs-lookup"><span data-stu-id="65b27-108">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="65b27-109">В этом разделе описано сопоставление между этим экземпляром XML-данных и JSON-содержимым для использования в сложных сценариях.</span><span class="sxs-lookup"><span data-stu-id="65b27-109">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>

<span data-ttu-id="65b27-110">Внутренне JSON представляется в виде информационного набора XML при обработке WCF.</span><span class="sxs-lookup"><span data-stu-id="65b27-110">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="65b27-111">Обычно внутреннее представление не должно заботить разработчика, поскольку сопоставление является исключительно логическим: JSON обычно не преобразуется физически в XML в памяти, равно как и XML не преобразуется в JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-111">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="65b27-112">Сопоставление означает, что для обращения к JSON-содержимому используются интерфейсы API XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-112">The mapping means that XML APIs are used to access JSON content.</span></span>

<span data-ttu-id="65b27-113">Когда WCF использует JSON, обычный сценарий заключается в том, что <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> автоматически подключается к <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> поведению или по <xref:System.ServiceModel.Description.WebHttpBehavior> поведению при необходимости.</span><span class="sxs-lookup"><span data-stu-id="65b27-113">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="65b27-114">Сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> понимает сопоставление между JSON и набором сведений XML и действует так, как будто работает непосредственно с JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-114">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="65b27-115">(Можно использовать сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> без какого-либо модуля чтения или записи XML, зная, что XML соответствует приведенному ниже сопоставлению).</span><span class="sxs-lookup"><span data-stu-id="65b27-115">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>

<span data-ttu-id="65b27-116">В сложных сценариях может понадобиться непосредственно обратиться к приведенному ниже сопоставлению.</span><span class="sxs-lookup"><span data-stu-id="65b27-116">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="65b27-117">Такие сценарии имеют место, когда требуется сериализовать десериализовать JSON особыми способами, не полагаясь на <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, или при использовании типа <xref:System.ServiceModel.Channels.Message> непосредственно для сообщений, содержащих JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-117">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="65b27-118">Сопоставление JSON-XML также используется для ведения журнала сообщений.</span><span class="sxs-lookup"><span data-stu-id="65b27-118">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="65b27-119">При использовании функции ведения журнала сообщений в WCF сообщения JSON регистрируются в виде XML-кода в соответствии с сопоставлением, описанным в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="65b27-119">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>

<span data-ttu-id="65b27-120">Для пояснения принципов сопоставления ниже приведен пример JSON-документа.</span><span class="sxs-lookup"><span data-stu-id="65b27-120">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>

```json
{"product":"pencil","price":12}
```

<span data-ttu-id="65b27-121">Для чтения этого JSON-документа с помощью одного из упомянутых выше модулей чтения используется та же последовательность вызовов класса <xref:System.Xml.XmlDictionaryReader>, что и для чтения следующего XML-документа.</span><span class="sxs-lookup"><span data-stu-id="65b27-121">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>

```xml
<root type="object">
    <product type="string">pencil</product>
    <price type="number">12</price>
</root>
```

<span data-ttu-id="65b27-122">Кроме того, если сообщение JSON в примере получено WCF и зарегистрировано, то в предыдущем журнале будет отображен фрагмент XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-122">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>

## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="65b27-123">Сопоставление между JSON и набором сведений XML</span><span class="sxs-lookup"><span data-stu-id="65b27-123">Mapping Between JSON and the XML Infoset</span></span>

<span data-ttu-id="65b27-124">Формально сопоставление происходит между JSON, как описано в [документе RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (за исключением определенных ограничений, ослабленных и других добавленных ограничений) и информационного набора XML (а не текстового XML), как описано в [наборе данных XML](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span><span class="sxs-lookup"><span data-stu-id="65b27-124">Formally, the mapping is between JSON as described in [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span></span> <span data-ttu-id="65b27-125">Определения *элементов информации* и полей в [квадратных скобках] см. в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="65b27-125">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>

<span data-ttu-id="65b27-126">Пустой документ JSON сопоставляется с пустым XML-документом, а пустой XML-документ сопоставляется с пустым документом JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-126">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="65b27-127">В сопоставлении XML с JSON, предшествующие пробелы и конечные пробелы после документа не допускаются.</span><span class="sxs-lookup"><span data-stu-id="65b27-127">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>

<span data-ttu-id="65b27-128">Сопоставление определяется между информационной единицей документа (Document Information Item, DII) и информационной единицей элемента (Element Information Item, EII) и JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-128">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="65b27-129">Информационная единица элемента (или свойство [document element] информационной единицы документа) называется корневым элементом JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-129">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="65b27-130">Обратите внимание, что фрагменты документов (XML-данные с несколькими корневыми элементами) в этом сопоставлении не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="65b27-130">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>

<span data-ttu-id="65b27-131">Пример. Следующий документ</span><span class="sxs-lookup"><span data-stu-id="65b27-131">Example: The following document:</span></span>

```xml
<?xml version="1.0"?>
<root type="number">42</root>
```

<span data-ttu-id="65b27-132">и следующий элемент</span><span class="sxs-lookup"><span data-stu-id="65b27-132">And the following element:</span></span>

```xml
<root type="number">42</root>
```

<span data-ttu-id="65b27-133">оба могут быть сопоставлены JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-133">Both have a mapping to JSON.</span></span> <span data-ttu-id="65b27-134">`root`Элемент> <является корневым ЭЛЕМЕНТОМ JSON в обоих случаях.</span><span class="sxs-lookup"><span data-stu-id="65b27-134">The <`root`> element is the Root JSON Element in both cases.</span></span>

<span data-ttu-id="65b27-135">Кроме того, в случае DII необходимо иметь в виду следующее.</span><span class="sxs-lookup"><span data-stu-id="65b27-135">Furthermore, in the case of a DII, the following should be considered:</span></span>

- <span data-ttu-id="65b27-136">Некоторые элементы в списке [children] присутствовать не должны.</span><span class="sxs-lookup"><span data-stu-id="65b27-136">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="65b27-137">Не следует полагаться на это при чтении XML-данных, полученных из JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-137">Do not rely on this fact when reading XML mapped from JSON.</span></span>

- <span data-ttu-id="65b27-138">Список [children] не содержит информационных единиц комментариев.</span><span class="sxs-lookup"><span data-stu-id="65b27-138">The [children] list holds no comment information items.</span></span>

- <span data-ttu-id="65b27-139">Список [children] не содержит информационных единиц DTD.</span><span class="sxs-lookup"><span data-stu-id="65b27-139">The [children] list holds no DTD information items.</span></span>

- <span data-ttu-id="65b27-140">Список [children] не содержит информационных единиц персональных данных (объявление `<?xml…>` не считается информационной единицей персональных данных).</span><span class="sxs-lookup"><span data-stu-id="65b27-140">The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)</span></span>

- <span data-ttu-id="65b27-141">Набор [notations] пуст.</span><span class="sxs-lookup"><span data-stu-id="65b27-141">The [notations] set is empty.</span></span>

- <span data-ttu-id="65b27-142">Набор [unparsed entities] пуст.</span><span class="sxs-lookup"><span data-stu-id="65b27-142">The [unparsed entities] set is empty.</span></span>

<span data-ttu-id="65b27-143">Пример. Следующий документ не может быть сопоставлен JSON, поскольку список [children] содержит персональные данные и комментарий.</span><span class="sxs-lookup"><span data-stu-id="65b27-143">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>

```xml
<?xml version="1.0"?>
<!--comment--><?pi?>
<root type="number">42</root>
```

<span data-ttu-id="65b27-144">EII для корневого элемента JSON имеет следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="65b27-144">The EII for the Root JSON Element has the following characteristics:</span></span>

- <span data-ttu-id="65b27-145">Свойство [local name] имеет значение "root".</span><span class="sxs-lookup"><span data-stu-id="65b27-145">[local name] has the value "root".</span></span>

- <span data-ttu-id="65b27-146">Свойство [namespace name] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-146">[namespace name] has no value.</span></span>

- <span data-ttu-id="65b27-147">Свойство [prefix] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-147">[prefix] has no value.</span></span>

- <span data-ttu-id="65b27-148">Список [children] может содержать информационные единицы элементов (которые представляют внутренние элементы; см. описание ниже) или информационные единицы символов (Character Information Item, CII; см. описание ниже) либо ни то, ни другое, но не то и другое одновременно.</span><span class="sxs-lookup"><span data-stu-id="65b27-148">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>

- <span data-ttu-id="65b27-149">Набор [attributes] может содержать приведенные ниже необязательные информационные единицы атрибутов (Attribute Information Item, AII).</span><span class="sxs-lookup"><span data-stu-id="65b27-149">[attributes] may contain the following optional attribute information items (AIIs)</span></span>

- <span data-ttu-id="65b27-150">Атрибут типа JSON ("type") (см. описание ниже).</span><span class="sxs-lookup"><span data-stu-id="65b27-150">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="65b27-151">Этот атрибут используется для сохранения типа JSON (string, number, boolean, object, array или null) в полученных в результате сопоставления XML-данных.</span><span class="sxs-lookup"><span data-stu-id="65b27-151">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>

- <span data-ttu-id="65b27-152">Атрибут имени контракта данных (" \_ \_ тип"), как описано далее.</span><span class="sxs-lookup"><span data-stu-id="65b27-152">The Data Contract Name Attribute ("\_\_type") as described further.</span></span> <span data-ttu-id="65b27-153">Этот атрибут может присутствовать только при условии, что присутствует также атрибут типа JSON и его свойство [normalized value] имеет значение "object".</span><span class="sxs-lookup"><span data-stu-id="65b27-153">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="65b27-154">Этот атрибут используется сериализатором `DataContractJsonSerializer` для сохранения сведений о типе контракта данных - например, в случаях полиморфизма, где сериализуется производный тип и где ожидается базовый тип.</span><span class="sxs-lookup"><span data-stu-id="65b27-154">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="65b27-155">Если используется не `DataContractJsonSerializer`, в большинстве случаев этот атрибут игнорируется.</span><span class="sxs-lookup"><span data-stu-id="65b27-155">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>

- <span data-ttu-id="65b27-156">[в пространствах имен в области] содержит привязку "XML" в `http://www.w3.org/XML/1998/namespace` соответствии со спецификацией информационного набора.</span><span class="sxs-lookup"><span data-stu-id="65b27-156">[in-scope namespaces] contains the binding of "xml" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.</span></span>

- <span data-ttu-id="65b27-157">Свойства [children], [attributes] и [in-scope namespaces] не должны содержать никаких единиц, кроме указанных выше, а свойство [namespace attributes] не должно иметь никаких членов; тем не менее, при чтении XML-данных, полученных из JSON, на это полагаться нельзя.</span><span class="sxs-lookup"><span data-stu-id="65b27-157">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>

<span data-ttu-id="65b27-158">Пример. Следующий документ не может быть сопоставлен JSON, поскольку набор [namespace attributes] не пуст.</span><span class="sxs-lookup"><span data-stu-id="65b27-158">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>

```xml
<?xml version="1.0"?>
<root xmlns:a="myattributevalue">42</root>
```

<span data-ttu-id="65b27-159">AII для атрибута типа JSON имеет следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="65b27-159">The AII for the JSON Type Attribute has the following characteristics:</span></span>

- <span data-ttu-id="65b27-160">Свойство [namespace name] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-160">[namespace name] has no value.</span></span>
- <span data-ttu-id="65b27-161">Свойство [prefix] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-161">[prefix] has no value.</span></span>
- <span data-ttu-id="65b27-162">Свойство [local name] имеет значение «type».</span><span class="sxs-lookup"><span data-stu-id="65b27-162">[local name] is "type".</span></span>
- <span data-ttu-id="65b27-163">Свойство [normalized value] имеет одно из возможных значений-типов, описанных в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="65b27-163">[normalized value] is one of the possible type values described in the following section.</span></span>
- <span data-ttu-id="65b27-164">Флаг [specified] имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="65b27-164">[specified] is `true`.</span></span>
- <span data-ttu-id="65b27-165">Свойство [attribute type] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-165">[attribute type] has no value.</span></span>
- <span data-ttu-id="65b27-166">Свойство [references] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-166">[references] has no value.</span></span>

<span data-ttu-id="65b27-167">AII для атрибута имени контракта данных JSON имеет следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="65b27-167">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>

- <span data-ttu-id="65b27-168">Свойство [namespace name] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-168">[namespace name] has no value.</span></span>
- <span data-ttu-id="65b27-169">Свойство [prefix] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-169">[prefix] has no value.</span></span>
- <span data-ttu-id="65b27-170">[local name] — " \_ \_ Type" (два символа подчеркивания и затем "тип").</span><span class="sxs-lookup"><span data-stu-id="65b27-170">[local name] is "\_\_type" (two underscores and then "type").</span></span>
- <span data-ttu-id="65b27-171">Свойство [normalized value] равно любой строке Юникод - сопоставление этой строки с JSON описывается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="65b27-171">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>
- <span data-ttu-id="65b27-172">Флаг [specified] имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="65b27-172">[specified] is `true`.</span></span>
- <span data-ttu-id="65b27-173">Свойство [attribute type] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-173">[attribute type] has no value.</span></span>
- <span data-ttu-id="65b27-174">Свойство [references] не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-174">[references] has no value.</span></span>

<span data-ttu-id="65b27-175">Внутренние элементы, содержащиеся в корневом элементе JSON или других внутренних элементах, имеют следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="65b27-175">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>

- <span data-ttu-id="65b27-176">[локальное имя] может иметь любое значение, как описано далее.</span><span class="sxs-lookup"><span data-stu-id="65b27-176">[local name] may have any value as described further.</span></span>
- <span data-ttu-id="65b27-177">Свойства [namespace name], [prefix], [children], [attributes], [namespace attributes] и [in-scope namespaces] подчиняются тем же правилам, что и корневой элемент JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-177">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>

<span data-ttu-id="65b27-178">И в корневом элементе JSON, и во внутренних элементах атрибут типа JSON определяет сопоставление с JSON, возможные дочерние информационные единицы ([children]) и их интерпретацию.</span><span class="sxs-lookup"><span data-stu-id="65b27-178">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="65b27-179">Атрибут [нормализованное значение] учитывает регистр, должен быть строчным и не может содержать пробелы.</span><span class="sxs-lookup"><span data-stu-id="65b27-179">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>

|<span data-ttu-id="65b27-180">[нормализованное значение] все атрибута типа JSON</span><span class="sxs-lookup"><span data-stu-id="65b27-180">[normalized value] of JSON Type Attribute’s AII</span></span>|<span data-ttu-id="65b27-181">Допустимые дочерние информационные единицы соответствующей EII</span><span class="sxs-lookup"><span data-stu-id="65b27-181">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="65b27-182">Соответствие в JSON</span><span class="sxs-lookup"><span data-stu-id="65b27-182">Mapping to JSON</span></span>|
|---------------------------------------------------------|---------------------------------------------------|---------------------|
|<span data-ttu-id="65b27-183">`string` (или отсутствие AII типа JSON)</span><span class="sxs-lookup"><span data-stu-id="65b27-183">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="65b27-184">`string` и отсутствие AII типа JSON - одно и то же, поэтому `string` используется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="65b27-184">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="65b27-185">Следовательно, `<root> string1</root>` соответствует `string` "string1" в JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-185">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="65b27-186">0 или более CII</span><span class="sxs-lookup"><span data-stu-id="65b27-186">0 or more CIIs</span></span>|<span data-ttu-id="65b27-187">Фрагмент JSON типа `string` (RFC по JSON, раздел 2.5).</span><span class="sxs-lookup"><span data-stu-id="65b27-187">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="65b27-188">Каждый фрагмент типа `char` - это символ, соответствующий свойству [character code] из CII.</span><span class="sxs-lookup"><span data-stu-id="65b27-188">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="65b27-189">Если CII нет, он сопоставляется пустому фрагменту JSON типа `string`.</span><span class="sxs-lookup"><span data-stu-id="65b27-189">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="65b27-190">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-190">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="65b27-191">Фрагмент JSON: "42".</span><span class="sxs-lookup"><span data-stu-id="65b27-191">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="65b27-192">При сопоставлении XML-JSON символы, которые должны быть снабжены escape-символом, сопоставляются символам с escape-символом, все остальные символы сопоставляются символам без escape-символа.</span><span class="sxs-lookup"><span data-stu-id="65b27-192">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="65b27-193">Символ "/" является специальным — он экранирован, даже если он не должен быть (записан как " \\ /").</span><span class="sxs-lookup"><span data-stu-id="65b27-193">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="65b27-194">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-194">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="65b27-195">Фрагмент JSON — это " \\ /та Da" \\ \\ .</span><span class="sxs-lookup"><span data-stu-id="65b27-195">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="65b27-196">При сопоставлении JSON-XML символы с escape-знаком и символы без escape-знака корректно сопоставляются соответствующему свойству [character code].</span><span class="sxs-lookup"><span data-stu-id="65b27-196">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="65b27-197">Пример. Фрагмент JSON "\u0041BC" сопоставляется следующему XML-элементу:</span><span class="sxs-lookup"><span data-stu-id="65b27-197">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="65b27-198">Строка может быть заключена в пробелы ("ws" в разделе 2 JSON RFC), которая не сопоставлена с XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-198">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="65b27-199">Пример. Фрагмент JSON           "ABC" (с пробелами перед первой двойной кавычкой) сопоставляется следующему XML-элементу:</span><span class="sxs-lookup"><span data-stu-id="65b27-199">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="65b27-200">Все пробелы в XML сопоставлены с пробелами в JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-200">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="65b27-201">Пример. Следующий XML-элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-201">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="65b27-202">Фрагмент JSON: " A BC ".</span><span class="sxs-lookup"><span data-stu-id="65b27-202">The JSON fragment is " A BC ".</span></span>|
|`number`|<span data-ttu-id="65b27-203">1 или более CII</span><span class="sxs-lookup"><span data-stu-id="65b27-203">1 or more CIIs</span></span>|<span data-ttu-id="65b27-204">JSON `number` (JSON RFC, раздел 2,4), возможно, окружен пробелами.</span><span class="sxs-lookup"><span data-stu-id="65b27-204">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="65b27-205">Каждый символ в сочетании чисел и пробелов является символом, который соответствует [коду символа] из ции.</span><span class="sxs-lookup"><span data-stu-id="65b27-205">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="65b27-206">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-206">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="65b27-207">Фрагмент JSON:    42</span><span class="sxs-lookup"><span data-stu-id="65b27-207">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="65b27-208">(Пробел сохраняется).</span><span class="sxs-lookup"><span data-stu-id="65b27-208">(White space is preserved).</span></span>|
|`boolean`|<span data-ttu-id="65b27-209">4 или 5 CII (что соответствует `true` или `false` ), возможно, окружены дополнительными пробелами CII.</span><span class="sxs-lookup"><span data-stu-id="65b27-209">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="65b27-210">Последовательность CII, соответствующая строке "true", сопоставляется литералу `true`, а последовательность CII, соответствующая строке "false", сопоставляется литералу `false`.</span><span class="sxs-lookup"><span data-stu-id="65b27-210">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="65b27-211">Окружающие пробелы сохраняются.</span><span class="sxs-lookup"><span data-stu-id="65b27-211">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="65b27-212">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-212">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="65b27-213">Фрагмент JSON: `false`.</span><span class="sxs-lookup"><span data-stu-id="65b27-213">The JSON fragment is `false`.</span></span>|
|`null`|<span data-ttu-id="65b27-214">Не допускается ни одного.</span><span class="sxs-lookup"><span data-stu-id="65b27-214">None allowed.</span></span>|<span data-ttu-id="65b27-215">Литерал `null`.</span><span class="sxs-lookup"><span data-stu-id="65b27-215">The literal `null`.</span></span> <span data-ttu-id="65b27-216">Для сопоставления JSON с XML `null` может быть окружено пробелом ("ws" в разделе 2), который не сопоставлен с XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-216">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="65b27-217">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-217">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="65b27-218">или</span><span class="sxs-lookup"><span data-stu-id="65b27-218">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="65b27-219">:</span><span class="sxs-lookup"><span data-stu-id="65b27-219">:</span></span><br /><br /> <span data-ttu-id="65b27-220">Фрагмент JSON в обоих случаях - `Null`.</span><span class="sxs-lookup"><span data-stu-id="65b27-220">The JSON fragment in both cases is `Null`.</span></span>|
|`object`|<span data-ttu-id="65b27-221">0 или более EII.</span><span class="sxs-lookup"><span data-stu-id="65b27-221">0 or more EIIs.</span></span>|<span data-ttu-id="65b27-222">Фрагмент `begin-object` (левая фигурная скобка), согласно разделу 2.2 RFC по JSON, после которой идет запись-член для каждой EII, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="65b27-222">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="65b27-223">Если EII больше одной, между записями-членами ставятся разделители значений (запятые).</span><span class="sxs-lookup"><span data-stu-id="65b27-223">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="65b27-224">После этого идет фрагмент end-object (правая фигурная скобка).</span><span class="sxs-lookup"><span data-stu-id="65b27-224">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="65b27-225">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-225">Example: The following element maps to the JSON fragment.</span></span><br /><br /> `<root type="object">`<br /><br /> `<type1 type="string">aaa\</type1>`<br /><br /> `<type2 type="string">bbb\</type2>`<br /><br /> `</root >`<br /><br /> <span data-ttu-id="65b27-226">Фрагмент JSON: `{"type1":"aaa","type2":"bbb"}`.</span><span class="sxs-lookup"><span data-stu-id="65b27-226">The JSON fragment is `{"type1":"aaa","type2":"bbb"}`.</span></span><br /><br /> <span data-ttu-id="65b27-227">Если в сопоставлении XML-JSON присутствует атрибут типа контракта данных, в начале вставляется дополнительная запись-член.</span><span class="sxs-lookup"><span data-stu-id="65b27-227">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="65b27-228">Его имя является [локальным именем] атрибута типа контракта данных (" \_ \_ тип"), а его значением является [нормализованное значение] атрибута.</span><span class="sxs-lookup"><span data-stu-id="65b27-228">Its name is the [local name] of the Data Contract Type Attribute ("\_\_type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="65b27-229">И наоборот, при сопоставлении JSON с XML, если имя первой записи члена является [локальным именем] атрибута типа контракта данных (то есть " \_ \_ тип"), соответствующий атрибут типа контракта данных содержится в сопоставленном XML, но соответствующий EII отсутствует.</span><span class="sxs-lookup"><span data-stu-id="65b27-229">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\_\_type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="65b27-230">Обратите внимание, что для применения этого особого сопоставления эта запись-член должна идти первой в объекте JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-230">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="65b27-231">Это отход от обычной обработки JSON, где порядок записей-членов не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="65b27-231">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="65b27-232">Пример.</span><span class="sxs-lookup"><span data-stu-id="65b27-232">Example:</span></span><br /><br /> <span data-ttu-id="65b27-233">Следующий фрагмент JSON сопоставляется XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-233">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="65b27-234">XML представляет собой следующий код.</span><span class="sxs-lookup"><span data-stu-id="65b27-234">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="65b27-235">Обратите внимание, что \_ \_ ПРИСУТСТВУЕТ тип все, но отсутствует \_ \_ тип EII.</span><span class="sxs-lookup"><span data-stu-id="65b27-235">Notice that the \_\_type AII is present, but there is no \_\_type EII.</span></span><br /><br /> <span data-ttu-id="65b27-236">Однако если порядок в JSON будет обратным, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="65b27-236">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> `{"name":"John","\_\_type":"Person"}`<br /><br /> <span data-ttu-id="65b27-237">соответствующий XML-код будет выглядеть так:</span><span class="sxs-lookup"><span data-stu-id="65b27-237">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="65b27-238">То есть \_ _Type прекращает иметь особое значение и сопоставляется с EII, как обычно, а не все.</span><span class="sxs-lookup"><span data-stu-id="65b27-238">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="65b27-239">Правила добавления/удаления escape-знаков для свойства [normalized value] AII при сопоставлении значению JSON такие же, как и для строк JSON (см. строку "string" выше в таблице).</span><span class="sxs-lookup"><span data-stu-id="65b27-239">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="65b27-240">Пример.</span><span class="sxs-lookup"><span data-stu-id="65b27-240">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="65b27-241">Предыдущий пример может быть сопоставлен следующему фрагменту JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-241">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="65b27-242">При сопоставлении XML с JSON первый EII [локальное имя] не должен быть " \_ \_ Type".</span><span class="sxs-lookup"><span data-stu-id="65b27-242">On an XML to JSON mapping, the first EII’s [local name] must not be "\_\_type".</span></span><br /><br /> <span data-ttu-id="65b27-243">Пробел ( `ws` ) никогда не создается при сопоставлении XML с JSON для объектов и игнорируется при сопоставлении JSON с XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-243">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="65b27-244">Пример. Следующий фрагмент JSON сопоставляется XML-элементу:</span><span class="sxs-lookup"><span data-stu-id="65b27-244">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> `{ "ccc" : "aaa", "ddd" :"bbb"}`<br /><br /> <span data-ttu-id="65b27-245">XML-элемент показан в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="65b27-245">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|
|<span data-ttu-id="65b27-246">array</span><span class="sxs-lookup"><span data-stu-id="65b27-246">array</span></span>|<span data-ttu-id="65b27-247">0 или более EII</span><span class="sxs-lookup"><span data-stu-id="65b27-247">0 or more EIIs</span></span>|<span data-ttu-id="65b27-248">Фрагмент begin-array (левая квадратная скобка), согласно разделу 2.3 RFC по JSON, после которой идет запись-массив для каждой EII, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="65b27-248">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="65b27-249">Если EII больше одной, между записями-массивами ставятся разделители значений (запятые).</span><span class="sxs-lookup"><span data-stu-id="65b27-249">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="65b27-250">После этого идет фрагмент end-array.</span><span class="sxs-lookup"><span data-stu-id="65b27-250">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="65b27-251">Пример. Следующий XML-элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-251">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="65b27-252">Фрагмент JSON `["aaa","bbb"]`</span><span class="sxs-lookup"><span data-stu-id="65b27-252">The JSON fragment is `["aaa","bbb"]`</span></span><br /><br /> <span data-ttu-id="65b27-253">Пробел ( `ws` ) никогда не создается в сопоставлении XML с JSON для массивов и игнорируется в сопоставлении JSON с XML.</span><span class="sxs-lookup"><span data-stu-id="65b27-253">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="65b27-254">Пример. фрагмент JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-254">Example: A JSON fragment.</span></span><br /><br />`["aaa", "bbb"]`<br /><br /> <span data-ttu-id="65b27-255">XML-элемент, которому он сопоставляется:</span><span class="sxs-lookup"><span data-stu-id="65b27-255">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|

<span data-ttu-id="65b27-256">Записи-члены работают следующим образом.</span><span class="sxs-lookup"><span data-stu-id="65b27-256">Member Records work as follows:</span></span>

- <span data-ttu-id="65b27-257">Свойство [local name] внутреннего элемента сопоставляется `string`-части фрагмента `member`, согласно 2.2 RFC по JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-257">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>

<span data-ttu-id="65b27-258">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-258">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName type="string">aaa</myLocalName>
</root>
```

<span data-ttu-id="65b27-259">Получается следующий фрагмент JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-259">The following JSON fragment is displayed.</span></span>

```json
{"myLocalName":"aaa"}
```

- <span data-ttu-id="65b27-260">При сопоставлении XML-JSON символы, которые в JSON должны быть снабжены escape-знаком, предваряются escape-знаком, остальные символы - нет.</span><span class="sxs-lookup"><span data-stu-id="65b27-260">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="65b27-261">Символ "/", хотя и не является требующим escape-знака символом, тем не менее предваряется escape-знаком (при сопоставлении JSON-XML предварять escape-знаком его не нужно).</span><span class="sxs-lookup"><span data-stu-id="65b27-261">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="65b27-262">Это необходимо для поддержки формата AJAX ASP.NET для данных типа `DateTime` в JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-262">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>

- <span data-ttu-id="65b27-263">При сопоставлении JSON-XML все символы (включая символы без escape-знака, если необходимо) используются для формирования фрагмента типа `string`, который представляет собой значение свойства [local name].</span><span class="sxs-lookup"><span data-stu-id="65b27-263">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>

- <span data-ttu-id="65b27-264">Внутренние элементы (список [children]) сопоставляются значению в разделе 2.2, в соответствии с атрибутом типа JSON (`JSON Type Attribute`), аналогично корневому элементу JSON (`Root JSON Element`).</span><span class="sxs-lookup"><span data-stu-id="65b27-264">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="65b27-265">Несколько уровней вложения EII (включая вложения в массивах) допустимы.</span><span class="sxs-lookup"><span data-stu-id="65b27-265">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>

<span data-ttu-id="65b27-266">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-266">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName1 type="string">myValue1</myLocalName1>
    <myLocalName2 type="number">2</myLocalName2>
    <myLocalName3 type="object">
        <myNestedName1 type="boolean">true</myNestedName1>
        <myNestedName2 type="null"/>
    </myLocalName3>
</root >
```

<span data-ttu-id="65b27-267">В результате получается следующий фрагмент JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-267">The following JSON fragment is what it maps to.</span></span>

```json
{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}
```

> [!NOTE]
> <span data-ttu-id="65b27-268">В показанном выше сопоставлении отсутствует этап XML-кодирования.</span><span class="sxs-lookup"><span data-stu-id="65b27-268">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="65b27-269">Поэтому WCF поддерживает только документы JSON, в которых все символы в именах ключей являются допустимыми символами в именах XML-элементов.</span><span class="sxs-lookup"><span data-stu-id="65b27-269">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="65b27-270">Например, документ JSON {"<": "a"} не поддерживается, так как < не является допустимым именем для XML-элемента.</span><span class="sxs-lookup"><span data-stu-id="65b27-270">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>

<span data-ttu-id="65b27-271">Обратная ситуация (символы, допустимые в XML, но недопустимые в JSON) никаких проблем не вызывает, поскольку описанное выше сопоставление предусматривает добавление или удаление escape-символов JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-271">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>

<span data-ttu-id="65b27-272">Записи-массивы работают следующим образом.</span><span class="sxs-lookup"><span data-stu-id="65b27-272">Array Records work as follows:</span></span>

- <span data-ttu-id="65b27-273">Свойство [local name] внутреннего элемента имеет значение "item".</span><span class="sxs-lookup"><span data-stu-id="65b27-273">Inner element’s [local name] is "item".</span></span>

- <span data-ttu-id="65b27-274">Список [children] внутреннего элемента сопоставляется значению в разделе 2.3, в соответствии с атрибутом типа JSON, как и для корневого элемента JSON.</span><span class="sxs-lookup"><span data-stu-id="65b27-274">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="65b27-275">Несколько уровней вложения EII (включая вложения в объектах) допустимы.</span><span class="sxs-lookup"><span data-stu-id="65b27-275">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>

<span data-ttu-id="65b27-276">Пример. Следующий элемент сопоставляется фрагменту JSON:</span><span class="sxs-lookup"><span data-stu-id="65b27-276">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="array">
    <item type="string">myValue1</item>
    <item type="number">2</item>
    <item type="array">
    <item type="boolean">true</item>
    <item type="null"/></item>
</root>
```

<span data-ttu-id="65b27-277">Фрагмент JSON выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="65b27-277">The following is the JSON fragment.</span></span>

```json
["myValue1",2,[true,null]]
```

## <a name="see-also"></a><span data-ttu-id="65b27-278">См. также</span><span class="sxs-lookup"><span data-stu-id="65b27-278">See also</span></span>

- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>
- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>
- [<span data-ttu-id="65b27-279">Автономная сериализация JSON</span><span class="sxs-lookup"><span data-stu-id="65b27-279">Stand-Alone JSON Serialization</span></span>](stand-alone-json-serialization.md)
