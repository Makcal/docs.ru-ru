---
description: 'Дополнительные сведения о: Stand-Alone сериализации JSON с помощью DataContractJsonSerializer'
title: Stand-Alone сериализации JSON с помощью DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: c88a996eeac7e9e62caa7797bc0bf7cd68dfd67b
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793419"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="1724f-103">Stand-Alone сериализации JSON с помощью DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="1724f-103">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="1724f-104">Эта статья посвящена <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="1724f-104">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="1724f-105">В большинстве сценариев, в которых участвует сериализация и десериализация JSON, мы рекомендуем использовать API в [System.Text.Jsпространства имен](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-105">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="1724f-106">JSON (JavaScript Object Notation, объектная нотация JavaScript) - формат данных, предназначенный специально для использования JavaScript-кодом, выполняемым на веб-страницах внутри браузера.</span><span class="sxs-lookup"><span data-stu-id="1724f-106">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="1724f-107">Это формат данных по умолчанию, используемый службами ASP.NET AJAX, созданными в Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="1724f-107">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="1724f-108">Его также можно использовать при создании служб AJAX без интеграции с ASP.NET; в данном случае форматом по умолчанию является XML, однако можно выбрать и JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-108">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="1724f-109">Наконец, если требуется поддержка JSON, однако создаваемая служба не является службой AJAX, сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> позволяет непосредственно сериализовать объекты .NET в данные JSON и десериализовать такие данные обратно в экземпляры типов .NET.</span><span class="sxs-lookup"><span data-stu-id="1724f-109">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="1724f-110">Описание того, как это сделать, см. [в разделе инструкции. Сериализация и десериализация данных JSON](how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-110">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="1724f-111">При работе с JSON поддерживаются те же (за некоторыми исключениями) типы .NET, что поддерживаются сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="1724f-111">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="1724f-112">Список поддерживаемых типов см. в разделе Типы, [Поддерживаемые сериализатором контрактов данных](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-112">For a list of the types supported, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="1724f-113">К ним относится большинство примитивных типов, большинство типов массивов и коллекций, а также сложные типы, в которых используются атрибуты <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1724f-113">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="1724f-114">Сопоставление типов .NET типам JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-114">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="1724f-115">В следующей таблице показано соответствие между типами .NET и типами JSON/JavaScript, используемое при сопоставлении в процедурах сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="1724f-115">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="1724f-116">Типы .NET</span><span class="sxs-lookup"><span data-stu-id="1724f-116">.NET Types</span></span>|<span data-ttu-id="1724f-117">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="1724f-117">JSON/JavaScript</span></span>|<span data-ttu-id="1724f-118">Примечания</span><span class="sxs-lookup"><span data-stu-id="1724f-118">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="1724f-119">Все числовые типы, например <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="1724f-119">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="1724f-120">Число</span><span class="sxs-lookup"><span data-stu-id="1724f-120">Number</span></span>|<span data-ttu-id="1724f-121">Специальные значения, такие как `Double.NaN`, `Double.PositiveInfinity` и `Double.NegativeInfinity`, не поддерживаются и приводят к получению недопустимых JSON-данных.</span><span class="sxs-lookup"><span data-stu-id="1724f-121">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="1724f-122">Число</span><span class="sxs-lookup"><span data-stu-id="1724f-122">Number</span></span>|<span data-ttu-id="1724f-123">См. раздел «Перечисления и JSON» ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-123">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="1724f-124">Логическое</span><span class="sxs-lookup"><span data-stu-id="1724f-124">Boolean</span></span>|--|
|<span data-ttu-id="1724f-125"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="1724f-125"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="1724f-126">Строка</span><span class="sxs-lookup"><span data-stu-id="1724f-126">String</span></span>|--|
|<span data-ttu-id="1724f-127"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="1724f-127"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="1724f-128">Строка</span><span class="sxs-lookup"><span data-stu-id="1724f-128">String</span></span>|<span data-ttu-id="1724f-129">Формат этих типов в JSON такой же, как и в XML (по сути, TimeSpan в формате ISO 8601, GUID в формате "12345678-ABCD-ABCD-ABCD-1234567890AB" и URI в его форме естественной строки, такой как " http://www.example.com ").</span><span class="sxs-lookup"><span data-stu-id="1724f-129">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="1724f-130">Точные сведения см. в разделе [Справочник по схеме контракта данных](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-130">For precise information, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="1724f-131">Строка</span><span class="sxs-lookup"><span data-stu-id="1724f-131">String</span></span>|<span data-ttu-id="1724f-132">Формат - «имя:пространство_имен» (все до первого двоеточия является именем).</span><span class="sxs-lookup"><span data-stu-id="1724f-132">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="1724f-133">Имя или пространство имен может отсутствовать.</span><span class="sxs-lookup"><span data-stu-id="1724f-133">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="1724f-134">При отсутствии пространства имен можно также опустить двоеточие.</span><span class="sxs-lookup"><span data-stu-id="1724f-134">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="1724f-135"><xref:System.Array> типа <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="1724f-135"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="1724f-136">Массив чисел</span><span class="sxs-lookup"><span data-stu-id="1724f-136">Array of numbers</span></span>|<span data-ttu-id="1724f-137">Каждое число представляет значение одного байта.</span><span class="sxs-lookup"><span data-stu-id="1724f-137">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="1724f-138">DateTime или String</span><span class="sxs-lookup"><span data-stu-id="1724f-138">DateTime or String</span></span>|<span data-ttu-id="1724f-139">См. раздел «Даты-времена и JSON» ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-139">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="1724f-140">Сложный тип</span><span class="sxs-lookup"><span data-stu-id="1724f-140">Complex type</span></span>|<span data-ttu-id="1724f-141">См. раздел «Даты-времена и JSON» ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-141">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="1724f-142">Типы XML и ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="1724f-142">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="1724f-143"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="1724f-143"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="1724f-144">Массивы <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="1724f-144">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="1724f-145"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="1724f-145"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="1724f-146"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="1724f-146"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="1724f-147">Строка</span><span class="sxs-lookup"><span data-stu-id="1724f-147">String</span></span>|<span data-ttu-id="1724f-148">См. раздел «Типы XML и JSON» ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-148">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="1724f-149">Пустой сложный тип</span><span class="sxs-lookup"><span data-stu-id="1724f-149">Empty complex type</span></span>|--|
|<span data-ttu-id="1724f-150">Коллекции, словари и массивы</span><span class="sxs-lookup"><span data-stu-id="1724f-150">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="1724f-151">Array</span><span class="sxs-lookup"><span data-stu-id="1724f-151">Array</span></span>|<span data-ttu-id="1724f-152">См. раздел «Коллекции, словари и массивы» ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-152">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="1724f-153">Сложные типы (с примененным атрибутом <xref:System.Runtime.Serialization.DataContractAttribute> или <xref:System.SerializableAttribute>)</span><span class="sxs-lookup"><span data-stu-id="1724f-153">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="1724f-154">Сложный тип</span><span class="sxs-lookup"><span data-stu-id="1724f-154">Complex type</span></span>|<span data-ttu-id="1724f-155">Элементы данных становятся элементами сложного типа JavaScript.</span><span class="sxs-lookup"><span data-stu-id="1724f-155">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="1724f-156">Сложные типы (реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>)</span><span class="sxs-lookup"><span data-stu-id="1724f-156">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="1724f-157">Сложный тип</span><span class="sxs-lookup"><span data-stu-id="1724f-157">Complex type</span></span>|<span data-ttu-id="1724f-158">Сопоставляется аналогично другим сложным типам, однако некоторые типы <xref:System.Runtime.Serialization.ISerializable> не поддерживаются; см. раздел «Поддержка интерфейса ISerializable» ниже, в разделе «Дополнительные сведения для опытных пользователей».</span><span class="sxs-lookup"><span data-stu-id="1724f-158">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="1724f-159">Значение `Null` для любого типа</span><span class="sxs-lookup"><span data-stu-id="1724f-159">`Null` value for any type</span></span>|<span data-ttu-id="1724f-160">NULL</span><span class="sxs-lookup"><span data-stu-id="1724f-160">Null</span></span>|<span data-ttu-id="1724f-161">Типы значений, допускающие значение null, также поддерживаются и сопоставляются с JSON точно так же, как типы значений, не допускающие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="1724f-161">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="1724f-162">Перечисления и JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-162">Enumerations and JSON</span></span>

<span data-ttu-id="1724f-163">Значения элементов перечислений в JSON рассматриваются как числа в отличие от контрактов данных, куда они включаются как имена элементов.</span><span class="sxs-lookup"><span data-stu-id="1724f-163">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="1724f-164">Дополнительные сведения о обработке контракта данных см. в разделе [типы перечислений в контрактах данных](enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-164">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="1724f-165">Например, в случае перечисления `public enum Color {red, green, blue, yellow, pink}` при сериализации члена `yellow` получается число 3, а не строка "yellow".</span><span class="sxs-lookup"><span data-stu-id="1724f-165">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="1724f-166">Все члены типа `enum` сериализуемы.</span><span class="sxs-lookup"><span data-stu-id="1724f-166">All `enum` members are serializable.</span></span> <span data-ttu-id="1724f-167">Атрибуты <xref:System.Runtime.Serialization.EnumMemberAttribute> и <xref:System.NonSerializedAttribute> (если они используются) игнорируются.</span><span class="sxs-lookup"><span data-stu-id="1724f-167">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="1724f-168">Также возможна десериализация несуществующего значения `enum` - например, значение 87 можно десериализовать в упомянутое выше перечисление Color, даже несмотря на отсутствие соответствующего определенного имени цвета.</span><span class="sxs-lookup"><span data-stu-id="1724f-168">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="1724f-169">Флаговый тип `enum` не является особенным и рассматривается так же, как любой другой тип `enum`.</span><span class="sxs-lookup"><span data-stu-id="1724f-169">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="1724f-170">Даты-времена и JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-170">Dates/Times and JSON</span></span>

<span data-ttu-id="1724f-171">Формат JSON не предусматривает непосредственной поддержки дат и времен.</span><span class="sxs-lookup"><span data-stu-id="1724f-171">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="1724f-172">Тем не менее, они очень часто используются, и в ASP.NET AJAX предусмотрена особая поддержка для этих типов.</span><span class="sxs-lookup"><span data-stu-id="1724f-172">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="1724f-173">При использовании прокси-объектов ASP.NET AJAX тип <xref:System.DateTime> в .NET полностью соответствует типу `DateTime` в JavaScript.</span><span class="sxs-lookup"><span data-stu-id="1724f-173">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="1724f-174">Если ASP.NET не используется, тип <xref:System.DateTime> представляется в JSON в виде строки особого формата, который описан в разделе "Дополнительные сведения для опытных пользователей" ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-174">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="1724f-175"><xref:System.DateTimeOffset> представляется в JSON как сложный тип: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="1724f-175"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="1724f-176">Член `offsetMinutes` - это смещение местного времени относительно времени по Гринвичу (GMT, теперь также называемого временем в формате UTC), связанное с местоположением интересующего события.</span><span class="sxs-lookup"><span data-stu-id="1724f-176">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="1724f-177">Элемент `dateTime` представляет момент во времени, когда произошло интересующее событие (опять этот элемент становится типом `DateTime` в JavaScript, когда используется ASP.NET AJAX, и строкой, когда ASP.NET AJAX не используется).</span><span class="sxs-lookup"><span data-stu-id="1724f-177">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="1724f-178">При сериализации член `dateTime` всегда сериализуется в GMT.</span><span class="sxs-lookup"><span data-stu-id="1724f-178">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="1724f-179">Так, если описывается время 3:00 по Нью-Йорку, компонентом времени члена `dateTime` будет "8:00", а смещение в минутах `offsetMinutes` составит 300 (минус 300 минут, или 5 часов, относительно GMT).</span><span class="sxs-lookup"><span data-stu-id="1724f-179">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="1724f-180">В объектах <xref:System.DateTime> и <xref:System.DateTimeOffset> при сериализации в JSON информация сохраняется с точностью только до миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="1724f-180"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="1724f-181">Значения меньше миллисекунды (микро- и наносекунды) при сериализации теряются.</span><span class="sxs-lookup"><span data-stu-id="1724f-181">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="1724f-182">Типы XML и JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-182">XML Types and JSON</span></span>

<span data-ttu-id="1724f-183">Типы XML становятся строками JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-183">XML types become JSON strings.</span></span>

- <span data-ttu-id="1724f-184">Например, если элемент данных "q" типа XElement содержит \<abc/> , JSON будет иметь вид {"q": " \<abc/> "}.</span><span class="sxs-lookup"><span data-stu-id="1724f-184">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="1724f-185">Существуют некоторые особые правила, определяющие, как XML-данные заключаются в оболочку; более подробные сведения см. в разделе "Дополнительные сведения для опытных пользователей" ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-185">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="1724f-186">При использовании ASP.NET AJAX, если вместо строк JavaScript требуется использовать модель DOM XML, присвойте значение «XML» свойству <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebGetAttribute> или свойству <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1724f-186">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="1724f-187">Коллекции, словари и массивы</span><span class="sxs-lookup"><span data-stu-id="1724f-187">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="1724f-188">Все коллекции, словари и массивы представляются в JSON в виде массивов.</span><span class="sxs-lookup"><span data-stu-id="1724f-188">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="1724f-189">Все пользовательские типы с атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> в JSON-представлении игнорируются.</span><span class="sxs-lookup"><span data-stu-id="1724f-189">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="1724f-190">Словари не являются способом непосредственной работы с JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-190">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="1724f-191">\<string,object>Возможно, словарь не поддерживается аналогичным образом в WCF, как ожидалось при работе с другими технологиями JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-191">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="1724f-192">Например, если в словаре строка "abc" сопоставлена строке "xyz", а строка "def" строке 42, JSON-представление будет иметь вид не {"abc":"xyz","def":42}, а [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].</span><span class="sxs-lookup"><span data-stu-id="1724f-192">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="1724f-193">Если требуется работать непосредственно с JSON (обращаться к ключам и значениям динамически, без предварительного определения жесткого контракта), можно рассмотреть следующие варианты.</span><span class="sxs-lookup"><span data-stu-id="1724f-193">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="1724f-194">Рассмотрите возможность использования примера [слабо типизированной СЕРИАЛИЗАЦИИ JSON (AJAX)](../samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="1724f-194">Consider using the [Weakly-typed JSON Serialization (AJAX)](../samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="1724f-195">Использование интерфейса <xref:System.Runtime.Serialization.ISerializable> и конструкторов десериализации - эти два механизма позволяют обращаться к парам "ключ-значение" JSON при сериализации и десериализации соответственно, однако не работают в сценариях с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="1724f-195">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="1724f-196">Рассмотрите возможность работы с [сопоставлением между JSON и XML](mapping-between-json-and-xml.md) вместо использования сериализатора.</span><span class="sxs-lookup"><span data-stu-id="1724f-196">Consider working with the [Mapping Between JSON and XML](mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="1724f-197">*Полиморфизм* в контексте сериализации относится к возможности сериализации производного типа, где ожидается его базовый тип.</span><span class="sxs-lookup"><span data-stu-id="1724f-197">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="1724f-198">Существуют особые (только для JSON) правила, применяющиеся при полиморфном использовании коллекций, например при присвоении коллекции объекту <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1724f-198">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="1724f-199">Этот вопрос более подробно рассмотрен в разделе "Дополнительные сведения для опытных пользователей" ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-199">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="1724f-200">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="1724f-200">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="1724f-201">Порядок членов данных</span><span class="sxs-lookup"><span data-stu-id="1724f-201">Order of Data Members</span></span>

<span data-ttu-id="1724f-202">Порядок членов данных при использовании JSON не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="1724f-202">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="1724f-203">В частности, даже если задан атрибут <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, JSON-данные все равно можно сериализовать в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="1724f-203">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="1724f-204">Типы JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-204">JSON Types</span></span>

<span data-ttu-id="1724f-205">Тип JSON при десериализации не обязательно должен соответствовать приведенной выше таблице.</span><span class="sxs-lookup"><span data-stu-id="1724f-205">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="1724f-206">Например, тип `Int` обычно сопоставляется числу JSON, однако может быть успешно десериализован из строки JSON, при условии, что строка содержит допустимое число.</span><span class="sxs-lookup"><span data-stu-id="1724f-206">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="1724f-207">То есть, и {"q":42}, и {"q":"42"} допустимы, если имеется член данных типа `Int` с именем "q".</span><span class="sxs-lookup"><span data-stu-id="1724f-207">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="1724f-208">Полиморфизм</span><span class="sxs-lookup"><span data-stu-id="1724f-208">Polymorphism</span></span>

<span data-ttu-id="1724f-209">Полиморфная сериализация состоит в возможности сериализовать производный тип там, где ожидается его базовый тип.</span><span class="sxs-lookup"><span data-stu-id="1724f-209">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="1724f-210">Это поддерживается для сериализации JSON с помощью WCF, сравнимой с способом поддержки сериализации XML.</span><span class="sxs-lookup"><span data-stu-id="1724f-210">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="1724f-211">Например, можно сериализовать `MyDerivedType` `MyBaseType` , где ожидается, или сериализовать, `Int` где `Object` ожидается.</span><span class="sxs-lookup"><span data-stu-id="1724f-211">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="1724f-212">При десериализации производного типа там, где ожидается базовый тип, информация типа может быть потеряна, за исключением случаев десериализации сложных типов.</span><span class="sxs-lookup"><span data-stu-id="1724f-212">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="1724f-213">Например, при сериализации типа <xref:System.Uri> там, где ожидается тип <xref:System.Object>, будет получена строка JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-213">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="1724f-214">Если эту строку затем десериализовать обратно в тип <xref:System.Object>, будет возвращен .NET-тип <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="1724f-214">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="1724f-215">Десериализатор не знает, что строка изначально имела тип <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="1724f-215">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="1724f-216">Как правило, когда ожидается тип <xref:System.Object>, все строки JSON десериализуются как строки .NET, а все массивы JSON, используемые для сериализации коллекций, словарей и массивов .NET, десериализуются как .NET-объекты <xref:System.Array> типа <xref:System.Object>, вне зависимости от того, какими были исходные типы.</span><span class="sxs-lookup"><span data-stu-id="1724f-216">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="1724f-217">Логический тип JSON сопоставляется .NET-типу <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="1724f-217">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="1724f-218">Однако, когда ожидается тип <xref:System.Object>, числа JSON десериализуются в .NET-типы <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double> (наиболее подходящий тип выбирается автоматически).</span><span class="sxs-lookup"><span data-stu-id="1724f-218">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="1724f-219">При десериализации в тип интерфейса <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> выполняет десериализацию так, как будто объявленный тип - объект.</span><span class="sxs-lookup"><span data-stu-id="1724f-219">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="1724f-220">При работе со своими собственными базовыми и производными типами обычно требуется использовать атрибуты <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> или эквивалентный механизм.</span><span class="sxs-lookup"><span data-stu-id="1724f-220">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="1724f-221">Например, если имеется операция, имеющая `Animal` возвращаемое значение, и она фактически возвращает экземпляр `Cat` (производный от `Animal` ), необходимо либо применить к <xref:System.Runtime.Serialization.KnownTypeAttribute> `Animal` типу, либо <xref:System.ServiceModel.ServiceKnownTypeAttribute> к операции и указать `Cat` тип в этих атрибутах.</span><span class="sxs-lookup"><span data-stu-id="1724f-221">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="1724f-222">Дополнительные сведения см. в статье о [известных типах контрактов данных](data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-222">For more information, see [Data Contract Known Types](data-contract-known-types.md).</span></span>

<span data-ttu-id="1724f-223">Подробное описание работы полиморфной сериализации и некоторых ограничений, которые необходимо принимать во внимание при ее использовании, см. в разделе "Дополнительные сведения для опытных пользователей" ниже.</span><span class="sxs-lookup"><span data-stu-id="1724f-223">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="1724f-224">Управление версиями</span><span class="sxs-lookup"><span data-stu-id="1724f-224">Versioning</span></span>

<span data-ttu-id="1724f-225">Возможности управления версиями контрактов данных, включая интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>, полностью поддерживаются в JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-225">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="1724f-226">Кроме того, в большинстве случаев можно десериализовать тип в один формат (например, XML) и затем сериализовать его в другой формат (например, JSON) и при этом сохранить данные в <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="1724f-226">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="1724f-227">Дополнительные сведения о создании контрактов данных, обладающих прямой совместимостью, см. в разделе [Контракты данных, совместимые с любыми будущими изменениями](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-227">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="1724f-228">Следует помнить, что JSON не придает значения порядку, поэтому любая информация о порядке будет потеряна.</span><span class="sxs-lookup"><span data-stu-id="1724f-228">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="1724f-229">Кроме того, JSON не поддерживает множественные пары "ключ/значение" с одним и тем же именем ключа.</span><span class="sxs-lookup"><span data-stu-id="1724f-229">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="1724f-230">Наконец, все операции над объектом <xref:System.Runtime.Serialization.IExtensibleDataObject> по своей природе полиморфны - то есть, их производные типы присваиваются типу <xref:System.Object>, базовому типу для всех типов.</span><span class="sxs-lookup"><span data-stu-id="1724f-230">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="1724f-231">JSON в URL-адресах</span><span class="sxs-lookup"><span data-stu-id="1724f-231">JSON in URLs</span></span>

<span data-ttu-id="1724f-232">При использовании конечных точек ASP.NET AJAX с командой GET HTTP (с помощью атрибута <xref:System.ServiceModel.Web.WebGetAttribute>), входящие параметры присутствуют в URL-адресе запроса, а не в теле сообщения.</span><span class="sxs-lookup"><span data-stu-id="1724f-232">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="1724f-233">JSON поддерживается даже в URL-адресе запроса, поэтому при наличии операции, которая принимает `Int` вызванный "номер" и `Person` сложный тип с именем "p", URL-адрес может выглядеть следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-233">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="1724f-234">При использовании диспетчера скриптов ASP.NET AJAX и прокси-объекта для вызова службы этот URL-адрес автоматически формируется прокси-объектом, и увидеть его нельзя.</span><span class="sxs-lookup"><span data-stu-id="1724f-234">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="1724f-235">JSON нельзя использовать в URL-адресах на конечных точках, не являющихся конечными точками ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="1724f-235">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="1724f-236">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="1724f-236">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="1724f-237">Поддержка интерфейса ISerializable</span><span class="sxs-lookup"><span data-stu-id="1724f-237">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="1724f-238">Поддерживаемые и неподдерживаемые типы ISerializable</span><span class="sxs-lookup"><span data-stu-id="1724f-238">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="1724f-239">Как правило, типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>, полностью поддерживаются при сериализации/десериализации JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-239">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="1724f-240">Однако некоторые из этих типов (включая некоторые типы платформы .NET Framework) реализованы так, что некоторые аспекты, присущие именно сериализации в JSON, не позволяют им правильно десериализоваться:</span><span class="sxs-lookup"><span data-stu-id="1724f-240">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="1724f-241">При использовании интерфейса <xref:System.Runtime.Serialization.ISerializable> тип отдельных членов данных никогда не известен заранее.</span><span class="sxs-lookup"><span data-stu-id="1724f-241">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="1724f-242">Это ведет к полиморфной ситуации, аналогичной десериализации типов в объект.</span><span class="sxs-lookup"><span data-stu-id="1724f-242">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="1724f-243">Как уже говорилось, это может привести к потере информации типов в JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-243">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="1724f-244">Например, если тип сериализует в своей реализации `enum` тип <xref:System.Runtime.Serialization.ISerializable>, попытка десериализовать данные обратно в `enum` (без надлежащих приведений) завершится неудачей, поскольку тип `enum` сериализуется в JSON в виде чисел, а числа JSON десериализуются во встроенные числовые типы .NET (Int32, Decimal или Double).</span><span class="sxs-lookup"><span data-stu-id="1724f-244">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="1724f-245">Поэтому тот факт, что число когда-то было значением перечисления (`enum`), теряется.</span><span class="sxs-lookup"><span data-stu-id="1724f-245">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="1724f-246">Тип с интерфейсом <xref:System.Runtime.Serialization.ISerializable>, конструктор десериализации которого основан на определенном порядке десериализации, также может выдать ошибку при десериализации некоторых JSON-данных, поскольку большинство сериализаторов JSON не гарантируют никакого определенного порядка.</span><span class="sxs-lookup"><span data-stu-id="1724f-246">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="1724f-247">Типы производства</span><span class="sxs-lookup"><span data-stu-id="1724f-247">Factory Types</span></span>

<span data-ttu-id="1724f-248">В то время как интерфейс <xref:System.Runtime.Serialization.IObjectReference> в общем случае поддерживается в JSON, все типы, требующие возможности "типа производства" (возвращения методом <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> экземпляра типа, отличного от типа, реализующего интерфейс), не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="1724f-248">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="1724f-249">Формат DateTime при передаче по линиям связи</span><span class="sxs-lookup"><span data-stu-id="1724f-249">DateTime Wire Format</span></span>

<span data-ttu-id="1724f-250">Значения типа <xref:System.DateTime> представляются строками JSON вида "/Date(700000+0500)/", где первое число (в данном случае 700000) - это число миллисекунд в часовом поясе GMT по обычному (не летнему) времени, прошедшее с 1 января 1970 г.</span><span class="sxs-lookup"><span data-stu-id="1724f-250"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="1724f-251">Это число может быть отрицательным для представления более раннего времени.</span><span class="sxs-lookup"><span data-stu-id="1724f-251">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="1724f-252">Часть строки "+0500" является необязательной и показывает, что это время в формате <xref:System.DateTimeKind.Local>, т. е. при десериализации оно должно быть преобразовано в местный часовой пояс.</span><span class="sxs-lookup"><span data-stu-id="1724f-252">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="1724f-253">Если эта часть строки отсутствует, время десериализуется как <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="1724f-253">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="1724f-254">Собственно число (в данном случае "0500") и его знак (+ или -) игнорируются.</span><span class="sxs-lookup"><span data-stu-id="1724f-254">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="1724f-255">При сериализации времен формата <xref:System.DateTime>, <xref:System.DateTimeKind.Local> и <xref:System.DateTimeKind.Unspecified> времена записываются со смещением, а время формата <xref:System.DateTimeKind.Utc> записывается без смещения.</span><span class="sxs-lookup"><span data-stu-id="1724f-255">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="1724f-256">JavaScript-код клиента ASP.NET AJAX автоматически преобразует такие строки в экземпляры `DateTime` JavaScript.</span><span class="sxs-lookup"><span data-stu-id="1724f-256">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="1724f-257">При наличии других строк аналогичного вида, не принадлежащих к типу <xref:System.DateTime> в .NET, они также преобразуются.</span><span class="sxs-lookup"><span data-stu-id="1724f-257">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="1724f-258">Преобразование выполняется только в том случае, если символы "/" экранированы (то есть JSON выглядит как " \\ /дате (700000 + 0500) \\ /"), и по этой причине кодировщик JSON в WCF (включенный <xref:System.ServiceModel.WebHttpBinding> ) всегда помещает символ "/" в escape-последовательность.</span><span class="sxs-lookup"><span data-stu-id="1724f-258">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="1724f-259">XML-данные в строках JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-259">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="1724f-260">XmlElement</span><span class="sxs-lookup"><span data-stu-id="1724f-260">XmlElement</span></span>

<span data-ttu-id="1724f-261">Тип <xref:System.Xml.XmlElement> сериализуется "как есть", без оболочки.</span><span class="sxs-lookup"><span data-stu-id="1724f-261"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="1724f-262">Например, элемент данных «x» типа <xref:System.Xml.XmlElement> , который содержит, \<abc/> представлен следующим образом:</span><span class="sxs-lookup"><span data-stu-id="1724f-262">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="1724f-263">Массивы типа XmlNode</span><span class="sxs-lookup"><span data-stu-id="1724f-263">Arrays of XmlNode</span></span>

<span data-ttu-id="1724f-264">Объекты <xref:System.Array> типа <xref:System.Xml.XmlNode> помещаются в элемент-оболочку ArrayOfXmlNode в стандартном пространстве имен контракта данных для данного типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-264"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="1724f-265">Если "x" - массив, содержащий узел атрибута "N" в пространстве имен "ns", который содержит "value", и пустой узел элемента "M", представление выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-265">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="1724f-266">Атрибуты в пустом пространстве имен в начале массивов XmlNode (перед другими элементами) не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="1724f-266">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="1724f-267">Типы IXmlSerializable, включая XElement и DataSet</span><span class="sxs-lookup"><span data-stu-id="1724f-267">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="1724f-268">Типы <xref:System.Runtime.Serialization.ISerializable> делятся на "типы содержимого", "типы DataSet" и "типы элементов".</span><span class="sxs-lookup"><span data-stu-id="1724f-268"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="1724f-269">Определения этих типов см. в разделе [типы XML и ADO.NET в контрактах данных](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-269">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="1724f-270">Типы содержимого и типы "DataSet" сериализуются аналогично объектам <xref:System.Array> типа <xref:System.Xml.XmlNode>, рассмотренным в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="1724f-270">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="1724f-271">Они помещаются в элемент-оболочку, имя и пространство имен которого соответствует имени контракта данных и пространству имен сериализуемого типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-271">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="1724f-272">Типы элементов, такие как <xref:System.Xml.Linq.XElement> сериализуются "как есть", аналогично рассмотренному выше типу <xref:System.Xml.XmlElement>.</span><span class="sxs-lookup"><span data-stu-id="1724f-272">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="1724f-273">Полиморфизм</span><span class="sxs-lookup"><span data-stu-id="1724f-273">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="1724f-274">Сохранение информации типов</span><span class="sxs-lookup"><span data-stu-id="1724f-274">Preserving Type Information</span></span>

<span data-ttu-id="1724f-275">Как уже говорилось, полиморфизм поддерживается в JSON с некоторыми ограничениями.</span><span class="sxs-lookup"><span data-stu-id="1724f-275">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="1724f-276">JavaScript - слабо типизированный язык, и идентификация типа обычно не представляет проблем.</span><span class="sxs-lookup"><span data-stu-id="1724f-276">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="1724f-277">Однако при использовании JSON для обмена данными между строго типизированной системой (.NET) и слабо типизированной системой (JavaScript) полезно сохранить удостоверение типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-277">However, when using JSON to communicate between a strongly typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="1724f-278">Например, типы с именами контрактов данных "Square" и "Circle" наследуют от типа с именем контракта данных "Shape".</span><span class="sxs-lookup"><span data-stu-id="1724f-278">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="1724f-279">Если значение Circle передается из .NET в JavaScript и возвращается в метод .NET, ожидающий тип Shape, то в компоненте .NET желательно знать, что данный объект изначально принадлежал к типу Circle; в противном случае может быть потеряна информация, присутствующая только в производном типе (например, элемент данных radius в типе Circle).</span><span class="sxs-lookup"><span data-stu-id="1724f-279">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="1724f-280">Для сохранения удостоверения типа при сериализации в JSON сложных типов можно добавить "намек на тип", чтобы десериализатор распознавал этот намек и действовал соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-280">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="1724f-281">"Указание типа" — это пара "ключ-значение" JSON с именем ключа " \_ \_ Type" (два символа подчеркивания, за которыми следует слово "Type").</span><span class="sxs-lookup"><span data-stu-id="1724f-281">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="1724f-282">Значение представляет собой строку JSON вида "DataContractName:DataContractNamespace" (все до первого двоеточия является именем).</span><span class="sxs-lookup"><span data-stu-id="1724f-282">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="1724f-283">Продолжая предыдущий пример, тип "Circle" можно сериализовать следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-283">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="1724f-284">Намек на тип очень похож на атрибут `xsi:type`, определенный в стандарте XML Schema Instance и используемый при сериализации/десериализации XML.</span><span class="sxs-lookup"><span data-stu-id="1724f-284">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="1724f-285">Элементы данных с именем " \_ \_ тип" запрещены из-за возможного конфликта с указанием типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-285">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="1724f-286">Уменьшение размера намеков на тип</span><span class="sxs-lookup"><span data-stu-id="1724f-286">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="1724f-287">Чтобы уменьшить размер сообщений JSON, префикс пространства имен по умолчанию для контракта данных ( `http://schemas.datacontract.org/2004/07/` ) заменяется символом #.</span><span class="sxs-lookup"><span data-stu-id="1724f-287">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="1724f-288">(Чтобы сделать эту замену обратимой, используется правило экранирования: Если пространство имен начинается с символов "#" или " \\ ", к ним добавляется дополнительный \\ символ "").</span><span class="sxs-lookup"><span data-stu-id="1724f-288">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="1724f-289">Таким же, если "Circle" является типом в пространстве имен "MyApp. Shapes" .NET, его пространство имен контракта данных по умолчанию — `http://schemas.datacontract.org/2004/07/MyApp` .</span><span class="sxs-lookup"><span data-stu-id="1724f-289">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="1724f-290">Shapes, а его JSON-представление будет иметь следующий вид.</span><span class="sxs-lookup"><span data-stu-id="1724f-290">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="1724f-291">Как усеченные (#MyApp. Shapes), так и полные <http://schemas.datacontract.org/2004/07/MyApp.Shapes> имена () обучены при десериализации.</span><span class="sxs-lookup"><span data-stu-id="1724f-291">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="1724f-292">Положение намека на тип в объектах JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-292">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="1724f-293">Обратите внимание, что намек на тип в JSON-представлении должен стоять на первом месте.</span><span class="sxs-lookup"><span data-stu-id="1724f-293">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="1724f-294">Это единственный случай, когда порядок пар "ключ/значение" в обработке JSON имеет значение.</span><span class="sxs-lookup"><span data-stu-id="1724f-294">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="1724f-295">Например, следующий способ задания намека на тип допустимым не является.</span><span class="sxs-lookup"><span data-stu-id="1724f-295">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="1724f-296">Как в случае <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> с клиентскими страницами WCF, так и ASP.NET AJAX, в первую очередь всегда выдается подсказка типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-296">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="1724f-297">Намеки на тип применяются только к сложным типам</span><span class="sxs-lookup"><span data-stu-id="1724f-297">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="1724f-298">Способа выдавать намек на тип для несложных типов не существует.</span><span class="sxs-lookup"><span data-stu-id="1724f-298">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="1724f-299">Например, если операция имеет тип возвращаемого значения <xref:System.Object>, однако возвращает тип "Circle", JSON-представление может выглядеть так, как показано выше, и информация типа сохраняется.</span><span class="sxs-lookup"><span data-stu-id="1724f-299">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="1724f-300">Однако если возвращается универсальный код ресурса (URI), JSON-представление будет строкой, и тот факт, что строка используется для представления URI, теряется.</span><span class="sxs-lookup"><span data-stu-id="1724f-300">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="1724f-301">Это относится не только к примитивным типам, но также к коллекциям и массивам.</span><span class="sxs-lookup"><span data-stu-id="1724f-301">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="1724f-302">Когда выдается намеки на тип</span><span class="sxs-lookup"><span data-stu-id="1724f-302">When Are Type Hints Emitted</span></span>

<span data-ttu-id="1724f-303">Намеки на тип могут значительно увеличить размер сообщения (один из способов борьбы с этим - использовать более короткие пространства имен контрактов данных, если это возможно).</span><span class="sxs-lookup"><span data-stu-id="1724f-303">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="1724f-304">По этой причине выдача намеков на тип подчиняется следующим правилам.</span><span class="sxs-lookup"><span data-stu-id="1724f-304">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="1724f-305">При использовании ASP.NET AJAX намеки на тип выдаются всегда, когда это возможно, даже при отсутствии присвоения базовый/производный - например, даже если тип "Circle" присваивается типу "Circle".</span><span class="sxs-lookup"><span data-stu-id="1724f-305">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="1724f-306">(Это необходимо для полного включения процесса вызова из слабо типизированной среды JSON в строго типизированную среду .NET без неожиданной потери информации.)</span><span class="sxs-lookup"><span data-stu-id="1724f-306">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="1724f-307">При использовании служб AJAX без интеграции с ASP.NET намеки на тип выдаются только при наличии присвоения базовый/производный - т. е. когда тип "Circle" присваивается типу "Shape" или типу <xref:System.Object>, но не при присвоении типа "Circle" типу "Circle".</span><span class="sxs-lookup"><span data-stu-id="1724f-307">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="1724f-308">Это минимум информации, необходимый для правильной реализации клиента JavaScript, что повышает производительность, но не защищает от потери информации о типах в неправильно спроектированных клиентах.</span><span class="sxs-lookup"><span data-stu-id="1724f-308">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="1724f-309">Избегайте присвоений базовый/производный на сервере в принципе, чтобы избежать необходимости решения этой проблемы на клиенте.</span><span class="sxs-lookup"><span data-stu-id="1724f-309">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="1724f-310">При использовании типа <xref:System.Runtime.Serialization.DataContractSerializer> параметр конструктора `alwaysEmitTypeInformation` позволяет выбрать один из двух упомянутых выше режимов; по умолчанию используется значение "`false`" (выдавать намеки на тип только тогда, когда это необходимо).</span><span class="sxs-lookup"><span data-stu-id="1724f-310">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="1724f-311">Повторяющиеся имена членов данных</span><span class="sxs-lookup"><span data-stu-id="1724f-311">Duplicate Data Member Names</span></span>

<span data-ttu-id="1724f-312">Информация производного типа присутствует в одном объекте JSON вместе с информацией базового типа и может следовать в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="1724f-312">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="1724f-313">Например, `Shape` можно представить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-313">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="1724f-314">При этом тип "Circle" может быть представлен следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-314">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="1724f-315">Если базовый `Shape` тип также содержит элемент данных с именем " `radius` ", это приводит к конфликту в обеих сериализации (поскольку объекты JSON не могут иметь повторяющиеся имена ключей) и десериализации (поскольку неясно, относится ли "RADIUS" к `Shape.radius` или `Circle.radius` ).</span><span class="sxs-lookup"><span data-stu-id="1724f-315">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="1724f-316">Следовательно, тогда как использовать принцип "сокрытия свойств" (члены данных с одинаковым именем в базовом и производном классах) в классах контрактов данных обычно не рекомендуется, в случае с JSON его использование прямо запрещено.</span><span class="sxs-lookup"><span data-stu-id="1724f-316">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="1724f-317">Полиморфизм и типы IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="1724f-317">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="1724f-318">Типы <xref:System.Xml.Serialization.IXmlSerializable> можно полиморфно присваивать друг другу как обычно, при условии выполнения требований "известных типов" в соответствии с обычными правилами контракта данных.</span><span class="sxs-lookup"><span data-stu-id="1724f-318"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="1724f-319">Однако сериализация типа <xref:System.Xml.Serialization.IXmlSerializable> вместо типа <xref:System.Object> приводит к потере информации типа, поскольку результатом сериализации является строка JSON.</span><span class="sxs-lookup"><span data-stu-id="1724f-319">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="1724f-320">Полиморфизм и некоторые типы интерфейсов</span><span class="sxs-lookup"><span data-stu-id="1724f-320">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="1724f-321">Запрещается сериализовать тип коллекции или тип, реализующий интерфейс <xref:System.Xml.Serialization.IXmlSerializable>, там, где ожидается не являющийся коллекцией тип, который не сериализуется с использованием <xref:System.Xml.Serialization.IXmlSerializable> (за исключением <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="1724f-321">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="1724f-322">Например, Пользовательский интерфейс с именем `IMyInterface` и тип `MyType` , реализующий оба <xref:System.Collections.Generic.IEnumerable%601> типа `int` и `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="1724f-322">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="1724f-323">Возврат `MyType` из операции, тип возвращаемого значения которой запрещен, недоступен `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="1724f-323">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="1724f-324">Это обусловлено тем, что `MyType` должен быть сериализован как массив JSON и требует указания типа, как указано перед включением подсказки типа с массивами только со сложными типами.</span><span class="sxs-lookup"><span data-stu-id="1724f-324">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="1724f-325">Известные типы и конфигурация</span><span class="sxs-lookup"><span data-stu-id="1724f-325">Known Types and Configuration</span></span>

<span data-ttu-id="1724f-326">Все механизмы "известных типов", используемые сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>, аналогичным образом поддерживаются сериализатором <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="1724f-326">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="1724f-327">Оба сериализатора считывают один и тот же элемент конфигурации [\<dataContractSerializer>](../../configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) в [\<system.runtime.serialization>](../../configure-apps/file-schema/wcf/system-runtime-serialization.md) , чтобы обнаружить известные типы, добавленные с помощью файла конфигурации.</span><span class="sxs-lookup"><span data-stu-id="1724f-327">Both serializers read the same configuration element, [\<dataContractSerializer>](../../configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="1724f-328">Коллекции, присвоенные объекту</span><span class="sxs-lookup"><span data-stu-id="1724f-328">Collections Assigned to Object</span></span>

<span data-ttu-id="1724f-329">Коллекции, присвоенные объекту, сериализуются так, как будто они реализуют интерфейс <xref:System.Collections.Generic.IEnumerable%601>: в виде массива JSON, где каждая запись имеет намек на тип, если это сложный тип.</span><span class="sxs-lookup"><span data-stu-id="1724f-329">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="1724f-330">Например, тип, <xref:System.Collections.Generic.List%601> `Shape` которому присваивается значение, <xref:System.Object> выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1724f-330">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="1724f-331">При десериализации обратно в <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="1724f-331">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="1724f-332">`Shape` должен быть в списке известных типов.</span><span class="sxs-lookup"><span data-stu-id="1724f-332">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="1724f-333">Наличие <xref:System.Collections.Generic.List%601> типа `Shape` в известных типах не оказывает никакого влияния.</span><span class="sxs-lookup"><span data-stu-id="1724f-333">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="1724f-334">Обратите внимание, что в этом случае нет необходимости добавлять `Shape` в сериализацию известные типы. это делается автоматически.</span><span class="sxs-lookup"><span data-stu-id="1724f-334">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="1724f-335">Коллекция десериализуется как <xref:System.Array> тип <xref:System.Object> , содержащий `Shape` экземпляры.</span><span class="sxs-lookup"><span data-stu-id="1724f-335">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="1724f-336">Производные коллекции, присвоенные базовым коллекциям</span><span class="sxs-lookup"><span data-stu-id="1724f-336">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="1724f-337">При присвоении производной коллекции базовой коллекции коллекция обычно сериализуется так, как если бы она была коллекцией базового типа.</span><span class="sxs-lookup"><span data-stu-id="1724f-337">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="1724f-338">В то же время тип элемента производной коллекции нельзя присвоить типу элемента базовой коллекции: вызывается исключение.</span><span class="sxs-lookup"><span data-stu-id="1724f-338">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="1724f-339">Намеки на тип и словари</span><span class="sxs-lookup"><span data-stu-id="1724f-339">Type Hints and Dictionaries</span></span>

<span data-ttu-id="1724f-340">При присвоении словаря объекту <xref:System.Object> каждая запись "ключ" и "значение" в словаре рассматривается так, как если бы она была присвоена объекту <xref:System.Object>, и получает намек на тип.</span><span class="sxs-lookup"><span data-stu-id="1724f-340">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="1724f-341">При сериализации типов словарей на объект JSON, содержащий члены "Key" и "Value", не влияет значение параметра `alwaysEmitTypeInformation`: он содержит намек на тип только там, где этого требуют рассмотренные выше правила сериализации коллекций.</span><span class="sxs-lookup"><span data-stu-id="1724f-341">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="1724f-342">Допустимые имена ключей JSON</span><span class="sxs-lookup"><span data-stu-id="1724f-342">Valid JSON Key Names</span></span>

<span data-ttu-id="1724f-343">Сериализатор кодирует в XML имена ключей, не являющиеся допустимыми XML-именами.</span><span class="sxs-lookup"><span data-stu-id="1724f-343">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="1724f-344">Например, элемент данных с именем "123" будет иметь закодированное имя, например " \_ x0031 \_ \_ x0032 \_ \_ x0033 \_ ", так как "123" является недопустимым именем XML-элемента (начинается с цифры).</span><span class="sxs-lookup"><span data-stu-id="1724f-344">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="1724f-345">Аналогичная ситуация может возникнуть с некоторыми международными кодировками, которые не допускаются в XML-именах.</span><span class="sxs-lookup"><span data-stu-id="1724f-345">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="1724f-346">Объяснение этого влияния обработки XML на JSON см. в разделе [сопоставление JSON и XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="1724f-346">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1724f-347">См. также</span><span class="sxs-lookup"><span data-stu-id="1724f-347">See also</span></span>

- [<span data-ttu-id="1724f-348">Поддержка JSON и других форматов передачи данных</span><span class="sxs-lookup"><span data-stu-id="1724f-348">Support for JSON and Other Data Transfer Formats</span></span>](support-for-json-and-other-data-transfer-formats.md)
