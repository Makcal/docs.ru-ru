---
title: Правила разработки (анализ кода)
description: Сведения о правилах проектирования для анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 548e0eaaa6239a9b9ee6a08677cd720710bb48c2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99714135"
---
# <a name="design-rules"></a><span data-ttu-id="933c3-103">Правила разработки</span><span class="sxs-lookup"><span data-stu-id="933c3-103">Design rules</span></span>

<span data-ttu-id="933c3-104">Правила проектирования поддерживают соблюдение [платформа .NET Framework рекомендаций по проектированию](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="933c3-104">Design rules support adherence to the [.NET Framework design guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="933c3-105">Содержание раздела</span><span class="sxs-lookup"><span data-stu-id="933c3-105">In this section</span></span>

| <span data-ttu-id="933c3-106">Правило</span><span class="sxs-lookup"><span data-stu-id="933c3-106">Rule</span></span> | <span data-ttu-id="933c3-107">Описание</span><span class="sxs-lookup"><span data-stu-id="933c3-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="933c3-108">CA1000. Не объявляйте статические члены в универсальных типах</span><span class="sxs-lookup"><span data-stu-id="933c3-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="933c3-109">При вызове статического элемента универсального типа нужно указать аргумент этого типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="933c3-110">При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="933c3-111">В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать.</span><span class="sxs-lookup"><span data-stu-id="933c3-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="933c3-112">CA1001. Типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми</span><span class="sxs-lookup"><span data-stu-id="933c3-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="933c3-113">Класс объявляет и реализует поле экземпляра, которое является типом System. IDisposable, а класс не реализует IDisposable.</span><span class="sxs-lookup"><span data-stu-id="933c3-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="933c3-114">Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable.</span><span class="sxs-lookup"><span data-stu-id="933c3-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="933c3-115">CA1002. Не предоставляйте универсальные списки</span><span class="sxs-lookup"><span data-stu-id="933c3-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="933c3-116">System. Collections. Generic. List< (of \<(T> ) >) — это универсальная коллекция, предназначенная для повышения производительности, а не для наследования.</span><span class="sxs-lookup"><span data-stu-id="933c3-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="933c3-117">Поэтому виртуальные элементы в списке отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="933c3-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="933c3-118">Вместо этого для наследования следует предоставить универсальную коллекцию.</span><span class="sxs-lookup"><span data-stu-id="933c3-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="933c3-119">CA1003. Используйте экземпляры обработчика универсальных событий</span><span class="sxs-lookup"><span data-stu-id="933c3-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="933c3-120">Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый объект и второй тип, который может быть назначен EventArgs), а содержащая сборка предназначена для платформа .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="933c3-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="933c3-121">CA1005. Не используйте слишком много параметров в универсальных типах</span><span class="sxs-lookup"><span data-stu-id="933c3-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="933c3-122">Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="933c3-123">Обычно очевидно с одним параметром типа, как в списке \<T> , и в некоторых случаях с двумя параметрами типа, как в словаре \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="933c3-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="933c3-124">Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности.</span><span class="sxs-lookup"><span data-stu-id="933c3-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="933c3-125">CA1008. Перечисляемые типы должны иметь нулевое значение</span><span class="sxs-lookup"><span data-stu-id="933c3-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="933c3-126">Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю.</span><span class="sxs-lookup"><span data-stu-id="933c3-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="933c3-127">Перечисление без флагов должно определять член, используя нулевое значение, чтобы значение по умолчанию было допустимым значением перечисления.</span><span class="sxs-lookup"><span data-stu-id="933c3-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="933c3-128">Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения.</span><span class="sxs-lookup"><span data-stu-id="933c3-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="933c3-129">CA1010. Коллекции должны реализовать универсальный интерфейс</span><span class="sxs-lookup"><span data-stu-id="933c3-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="933c3-130">Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции.</span><span class="sxs-lookup"><span data-stu-id="933c3-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="933c3-131">Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции.</span><span class="sxs-lookup"><span data-stu-id="933c3-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="933c3-132">CA1012. Абстрактные типы не должны иметь конструкторы</span><span class="sxs-lookup"><span data-stu-id="933c3-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="933c3-133">Конструкторы абстрактных типов могут быть вызваны только производными типами.</span><span class="sxs-lookup"><span data-stu-id="933c3-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="933c3-134">Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="933c3-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="933c3-135">CA1014. Пометьте сборки с помощью CLSCompliantAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="933c3-136">Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования.</span><span class="sxs-lookup"><span data-stu-id="933c3-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="933c3-137">Хороший дизайн определяет, что все сборки явно указывают на совместимость с CLS с помощью CLSCompliantAttribute.</span><span class="sxs-lookup"><span data-stu-id="933c3-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="933c3-138">Если этот атрибут у сборки отсутствует, сборка несовместима.</span><span class="sxs-lookup"><span data-stu-id="933c3-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="933c3-139">CA1016. Пометьте сборки с помощью AssemblyVersionAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="933c3-140">.NET использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами.</span><span class="sxs-lookup"><span data-stu-id="933c3-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="933c3-141">Номер версии используется наряду с политикой версий и издателя.</span><span class="sxs-lookup"><span data-stu-id="933c3-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="933c3-142">По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения.</span><span class="sxs-lookup"><span data-stu-id="933c3-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="933c3-143">CA1017. Пометьте сборки с помощью ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="933c3-144">Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду.</span><span class="sxs-lookup"><span data-stu-id="933c3-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="933c3-145">Для правильной разработки сборки должны явным образом указывать видимость COM.</span><span class="sxs-lookup"><span data-stu-id="933c3-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="933c3-146">Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов.</span><span class="sxs-lookup"><span data-stu-id="933c3-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="933c3-147">Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM.</span><span class="sxs-lookup"><span data-stu-id="933c3-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="933c3-148">CA1018. Пометьте атрибуты с помощью AttributeUsageAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="933c3-149">При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде.</span><span class="sxs-lookup"><span data-stu-id="933c3-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="933c3-150">Допустимое положение атрибута в коде зависит от значения атрибута и его применения.</span><span class="sxs-lookup"><span data-stu-id="933c3-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="933c3-151">CA1019. Определите методы доступа для аргументов атрибута</span><span class="sxs-lookup"><span data-stu-id="933c3-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="933c3-152">Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту.</span><span class="sxs-lookup"><span data-stu-id="933c3-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="933c3-153">Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров.</span><span class="sxs-lookup"><span data-stu-id="933c3-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="933c3-154">Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="933c3-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="933c3-155">Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы.</span><span class="sxs-lookup"><span data-stu-id="933c3-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="933c3-156">Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи.</span><span class="sxs-lookup"><span data-stu-id="933c3-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="933c3-157">CA1021. Не используйте параметры out</span><span class="sxs-lookup"><span data-stu-id="933c3-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="933c3-158">Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями.</span><span class="sxs-lookup"><span data-stu-id="933c3-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="933c3-159">Кроме того, далеко не все понимают разницу между параметрами out и ref.</span><span class="sxs-lookup"><span data-stu-id="933c3-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="933c3-160">CA1024. По возможности используйте свойства</span><span class="sxs-lookup"><span data-stu-id="933c3-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="933c3-161">Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом.</span><span class="sxs-lookup"><span data-stu-id="933c3-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="933c3-162">Возможно, этот метод лучше преобразовать в свойство.</span><span class="sxs-lookup"><span data-stu-id="933c3-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="933c3-163">CA1027. Пометьте перечисляемые типы с помощью FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="933c3-164">Перечисление является типом значения, которое определяет набор связанных именованных констант.</span><span class="sxs-lookup"><span data-stu-id="933c3-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="933c3-165">Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом.</span><span class="sxs-lookup"><span data-stu-id="933c3-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="933c3-166">CA1028. Хранилище перечисляемых типов должно относиться к типу Int32</span><span class="sxs-lookup"><span data-stu-id="933c3-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="933c3-167">Перечисление является типом значения, которое определяет набор связанных именованных констант.</span><span class="sxs-lookup"><span data-stu-id="933c3-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="933c3-168">По умолчанию для хранения значения константы используется тип данных System.Int32.</span><span class="sxs-lookup"><span data-stu-id="933c3-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="933c3-169">Несмотря на то, что этот базовый тип можно изменить, он не является обязательным и не рекомендуется для большинства сценариев.</span><span class="sxs-lookup"><span data-stu-id="933c3-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="933c3-170">CA1030. По возможности используйте события</span><span class="sxs-lookup"><span data-stu-id="933c3-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="933c3-171">Данное правило отслеживает методы с именами, которые, как правило, используются для событий.</span><span class="sxs-lookup"><span data-stu-id="933c3-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="933c3-172">Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий.</span><span class="sxs-lookup"><span data-stu-id="933c3-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="933c3-173">Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую.</span><span class="sxs-lookup"><span data-stu-id="933c3-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="933c3-174">CA1031. Не перехватывайте типы общих исключений</span><span class="sxs-lookup"><span data-stu-id="933c3-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="933c3-175">Общие исключения не должны перехватываться.</span><span class="sxs-lookup"><span data-stu-id="933c3-175">General exceptions should not be caught.</span></span> <span data-ttu-id="933c3-176">Перехватите более конкретное исключение или повторно создайте общее исключение в качестве последней инструкции в блоке catch.</span><span class="sxs-lookup"><span data-stu-id="933c3-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="933c3-177">CA1032. Реализуйте стандартные конструкторы исключений</span><span class="sxs-lookup"><span data-stu-id="933c3-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="933c3-178">Для правильной обработки исключений необходимо предоставить полный набор конструкторов.</span><span class="sxs-lookup"><span data-stu-id="933c3-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="933c3-179">CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами</span><span class="sxs-lookup"><span data-stu-id="933c3-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="933c3-180">Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="933c3-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="933c3-181">CA1034. Вложенные типы не должны быть видимыми</span><span class="sxs-lookup"><span data-stu-id="933c3-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="933c3-182">Вложенный тип — это тип, объявленный внутри области другого типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="933c3-183">Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="933c3-184">В силу этого вложенные типы не должны быть видимыми для внешнего кода.</span><span class="sxs-lookup"><span data-stu-id="933c3-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="933c3-185">CA1036. Переопределите методы в сопоставимых типах</span><span class="sxs-lookup"><span data-stu-id="933c3-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="933c3-186">Открытый или защищенный тип реализует интерфейс System.IComparable.</span><span class="sxs-lookup"><span data-stu-id="933c3-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="933c3-187">Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше".</span><span class="sxs-lookup"><span data-stu-id="933c3-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="933c3-188">CA1040. Не используйте пустые интерфейсы</span><span class="sxs-lookup"><span data-stu-id="933c3-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="933c3-189">Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании.</span><span class="sxs-lookup"><span data-stu-id="933c3-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="933c3-190">Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса.</span><span class="sxs-lookup"><span data-stu-id="933c3-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="933c3-191">Тип реализует интерфейс путем предоставления реализаций для членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="933c3-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="933c3-192">Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать.</span><span class="sxs-lookup"><span data-stu-id="933c3-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="933c3-193">CA1041. Укажите сообщение ObsoleteAttribute</span><span class="sxs-lookup"><span data-stu-id="933c3-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="933c3-194">Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message.</span><span class="sxs-lookup"><span data-stu-id="933c3-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="933c3-195">При компиляции типа или члена, помеченного с помощью атрибута ObsoleteAttribute, отображается свойство Message атрибута, которое предоставляет пользователю сведения об устаревшем типе или члене.</span><span class="sxs-lookup"><span data-stu-id="933c3-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="933c3-196">CA1043. Используйте целый или строковый аргумент для индексаторов</span><span class="sxs-lookup"><span data-stu-id="933c3-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="933c3-197">Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы.</span><span class="sxs-lookup"><span data-stu-id="933c3-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="933c3-198">Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки.</span><span class="sxs-lookup"><span data-stu-id="933c3-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="933c3-199">Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип.</span><span class="sxs-lookup"><span data-stu-id="933c3-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="933c3-200">CA1044. Свойства не должны быть доступными только для записи</span><span class="sxs-lookup"><span data-stu-id="933c3-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="933c3-201">Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись.</span><span class="sxs-lookup"><span data-stu-id="933c3-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="933c3-202">Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность.</span><span class="sxs-lookup"><span data-stu-id="933c3-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="933c3-203">Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность.</span><span class="sxs-lookup"><span data-stu-id="933c3-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="933c3-204">CA1045. Не передавайте типы по ссылке</span><span class="sxs-lookup"><span data-stu-id="933c3-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="933c3-205">Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями.</span><span class="sxs-lookup"><span data-stu-id="933c3-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="933c3-206">Архитекторам, разрабатывающим библиотеки для широкого использования, не следует рассчитывать, что пользователи прекрасно разбираются в использовании параметров out и ref.</span><span class="sxs-lookup"><span data-stu-id="933c3-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="933c3-207">CA1046. Не перегружайте оператор равенства для ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="933c3-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="933c3-208">Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="933c3-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="933c3-209">По умолчанию две ссылки равны, если они указывают на один объект.</span><span class="sxs-lookup"><span data-stu-id="933c3-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="933c3-210">CA1047. Не объявляйте защищенные члены в запечатанных типах</span><span class="sxs-lookup"><span data-stu-id="933c3-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="933c3-211">Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его.</span><span class="sxs-lookup"><span data-stu-id="933c3-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="933c3-212">По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен.</span><span class="sxs-lookup"><span data-stu-id="933c3-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="933c3-213">CA1050. Объявите типы в пространствах имен</span><span class="sxs-lookup"><span data-stu-id="933c3-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="933c3-214">Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов.</span><span class="sxs-lookup"><span data-stu-id="933c3-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="933c3-215">CA1051. Не объявляйте видимые поля экземпляров</span><span class="sxs-lookup"><span data-stu-id="933c3-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="933c3-216">Поля главным образом следует использовать для данных реализации.</span><span class="sxs-lookup"><span data-stu-id="933c3-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="933c3-217">Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств.</span><span class="sxs-lookup"><span data-stu-id="933c3-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="933c3-218">CA1052. Типы со статическими заполнителями должны быть запечатаны</span><span class="sxs-lookup"><span data-stu-id="933c3-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="933c3-219">Открытый или защищенный тип содержит только статические члены и не объявляется с помощью модификатора sealed (C#) или NotInheritable (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="933c3-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="933c3-220">Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип.</span><span class="sxs-lookup"><span data-stu-id="933c3-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="933c3-221">CA1053. Типы со статическими заполнителями не должны иметь конструкторы</span><span class="sxs-lookup"><span data-stu-id="933c3-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="933c3-222">В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="933c3-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="933c3-223">Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа.</span><span class="sxs-lookup"><span data-stu-id="933c3-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="933c3-224">Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент.</span><span class="sxs-lookup"><span data-stu-id="933c3-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="933c3-225">CA1054. Параметры URI не должны быть строками</span><span class="sxs-lookup"><span data-stu-id="933c3-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="933c3-226">Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом.</span><span class="sxs-lookup"><span data-stu-id="933c3-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="933c3-227">CA1055. Возвращаемые значения URI не должны быть строками</span><span class="sxs-lookup"><span data-stu-id="933c3-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="933c3-228">В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="933c3-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="933c3-229">В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="933c3-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="933c3-230">Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом.</span><span class="sxs-lookup"><span data-stu-id="933c3-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="933c3-231">CA1056. Свойства URI не должны быть строками</span><span class="sxs-lookup"><span data-stu-id="933c3-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="933c3-232">Это правило предполагает, что свойство представляет универсальный код ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="933c3-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="933c3-233">В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="933c3-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="933c3-234">Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом.</span><span class="sxs-lookup"><span data-stu-id="933c3-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="933c3-235">CA1058. Типы не должны расширять определенные базовые типы</span><span class="sxs-lookup"><span data-stu-id="933c3-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="933c3-236">Видимый извне тип расширяет некоторые базовые типы.</span><span class="sxs-lookup"><span data-stu-id="933c3-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="933c3-237">Используйте только один вариант.</span><span class="sxs-lookup"><span data-stu-id="933c3-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="933c3-238">CA1060: перемещение P/Invoke в класс NativeMethods</span><span class="sxs-lookup"><span data-stu-id="933c3-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="933c3-239">Методы вызова платформы, такие как помеченные <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> методами или, определенные с помощью ключевого слова Declare в Visual Basic, обращаются к неуправляемому коду.</span><span class="sxs-lookup"><span data-stu-id="933c3-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="933c3-240">Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</span><span class="sxs-lookup"><span data-stu-id="933c3-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="933c3-241">CA1061. Не скрывайте методы базовых классов</span><span class="sxs-lookup"><span data-stu-id="933c3-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="933c3-242">Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода.</span><span class="sxs-lookup"><span data-stu-id="933c3-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="933c3-243">CA1062. Проверьте аргументы или открытые методы</span><span class="sxs-lookup"><span data-stu-id="933c3-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="933c3-244">Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL.</span><span class="sxs-lookup"><span data-stu-id="933c3-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="933c3-245">CA1063. Правильно реализуйте IDisposable</span><span class="sxs-lookup"><span data-stu-id="933c3-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="933c3-246">Все типы IDisposable должны правильно реализовывать шаблон "Dispose".</span><span class="sxs-lookup"><span data-stu-id="933c3-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="933c3-247">CA1064. Исключения должны быть общими</span><span class="sxs-lookup"><span data-stu-id="933c3-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="933c3-248">Внутреннее исключение видно только внутри своей внутренней области.</span><span class="sxs-lookup"><span data-stu-id="933c3-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="933c3-249">После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение.</span><span class="sxs-lookup"><span data-stu-id="933c3-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="933c3-250">Если внутреннее исключение наследуется от <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> или <xref:System.ApplicationException?displayProperty=fullName> , внешний код не будет иметь достаточных сведений, чтобы узнать, что делать с этим исключением.</span><span class="sxs-lookup"><span data-stu-id="933c3-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="933c3-251">CA1065. Не вызывайте исключения в непредвиденных местах</span><span class="sxs-lookup"><span data-stu-id="933c3-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="933c3-252">Метод вызывает исключение, хотя не должен этого делать.</span><span class="sxs-lookup"><span data-stu-id="933c3-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="933c3-253">CA1066: реализация IEquatable при переопределении Equals</span><span class="sxs-lookup"><span data-stu-id="933c3-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="933c3-254">Тип значения переопределяет <xref:System.Object.Equals%2A> метод, но не реализует <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="933c3-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="933c3-255">CA1067: переопределение Equals при реализации IEquatable</span><span class="sxs-lookup"><span data-stu-id="933c3-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="933c3-256">Тип реализует <xref:System.IEquatable%601> , но не переопределяет <xref:System.Object.Equals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="933c3-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="933c3-257">CA1068: Параметры CancellationToken должны быть последними</span><span class="sxs-lookup"><span data-stu-id="933c3-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="933c3-258">Метод имеет параметр CancellationToken, который не является последним параметром.</span><span class="sxs-lookup"><span data-stu-id="933c3-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="933c3-259">CA1069: перечисления не должны иметь повторяющихся значений</span><span class="sxs-lookup"><span data-stu-id="933c3-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="933c3-260">Перечисление содержит несколько членов, которым явным образом присвоено одно и то же значение константы.</span><span class="sxs-lookup"><span data-stu-id="933c3-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="933c3-261">CA1070: не объявляйте поля событий как виртуальные</span><span class="sxs-lookup"><span data-stu-id="933c3-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="933c3-262">[Событие, похожее на поле](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) , было объявлено как виртуальное.</span><span class="sxs-lookup"><span data-stu-id="933c3-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
