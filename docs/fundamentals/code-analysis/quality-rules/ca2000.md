---
title: 'CA2000: удаление объектов до потери области (анализ кода)'
description: 'Дополнительные сведения о правиле анализа кода CA2000: Dispose Objects до потери области'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
author: gewarren
ms.author: gewarren
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 2e8f2d58ae8f8799fde51cc15522277cbc90988a
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99792431"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a><span data-ttu-id="a3811-103">CA2000. Ликвидируйте объекты перед потерей области</span><span class="sxs-lookup"><span data-stu-id="a3811-103">CA2000: Dispose objects before losing scope</span></span>

| | <span data-ttu-id="a3811-104">Значение</span><span class="sxs-lookup"><span data-stu-id="a3811-104">Value</span></span> |
|-|-|
| <span data-ttu-id="a3811-105">**Идентификатор правила**</span><span class="sxs-lookup"><span data-stu-id="a3811-105">**Rule ID**</span></span> |<span data-ttu-id="a3811-106">CA2000</span><span class="sxs-lookup"><span data-stu-id="a3811-106">CA2000</span></span>|
| <span data-ttu-id="a3811-107">**Категория**</span><span class="sxs-lookup"><span data-stu-id="a3811-107">**Category**</span></span> |[<span data-ttu-id="a3811-108">Надежность</span><span class="sxs-lookup"><span data-stu-id="a3811-108">Reliability</span></span>](reliability-warnings.md)|
| <span data-ttu-id="a3811-109">**Исправление не критическое или не критическое**</span><span class="sxs-lookup"><span data-stu-id="a3811-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="a3811-110">Не критическое</span><span class="sxs-lookup"><span data-stu-id="a3811-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="a3811-111">Причина</span><span class="sxs-lookup"><span data-stu-id="a3811-111">Cause</span></span>

<span data-ttu-id="a3811-112">Создается локальный объект <xref:System.IDisposable> типа, но объект не удаляется до тех пор, пока все ссылки на объект не выходят за пределы области.</span><span class="sxs-lookup"><span data-stu-id="a3811-112">A local object of an <xref:System.IDisposable> type is created, but the object is not disposed before all references to the object are out of scope.</span></span>

<span data-ttu-id="a3811-113">По умолчанию это правило анализирует всю базу кода, но это можно [настроить](#configure-code-to-analyze).</span><span class="sxs-lookup"><span data-stu-id="a3811-113">By default, this rule analyzes the entire codebase, but this is [configurable](#configure-code-to-analyze).</span></span>

## <a name="rule-description"></a><span data-ttu-id="a3811-114">Описание правила</span><span class="sxs-lookup"><span data-stu-id="a3811-114">Rule description</span></span>

<span data-ttu-id="a3811-115">Если удаляемый объект не был явно удален до того, как все ссылки на него выходят за пределы области видимости, объект будет удален в неопределенное время, когда сборщик мусора выполняет метод завершения объекта.</span><span class="sxs-lookup"><span data-stu-id="a3811-115">If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object.</span></span> <span data-ttu-id="a3811-116">Так как может возникнуть исключительная ситуация, которая предотвратит выполнение метода завершения объекта, объект должен быть явно удален.</span><span class="sxs-lookup"><span data-stu-id="a3811-116">Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</span></span>

## <a name="special-cases"></a><span data-ttu-id="a3811-117">Особые случаи</span><span class="sxs-lookup"><span data-stu-id="a3811-117">Special cases</span></span>

<span data-ttu-id="a3811-118">Правило CA2000 не срабатывает для локальных объектов следующих типов, даже если объект не удален:</span><span class="sxs-lookup"><span data-stu-id="a3811-118">Rule CA2000 does not fire for local objects of the following types even if the object is not disposed:</span></span>

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

<span data-ttu-id="a3811-119">Передача объекта одного из этих типов в конструктор, а затем присваивание его полю указывает на *передачу владения владельцем* вновь сформированного типа.</span><span class="sxs-lookup"><span data-stu-id="a3811-119">Passing an object of one of these types to a constructor and then assigning it to a field indicates a *dispose ownership transfer* to the newly constructed type.</span></span> <span data-ttu-id="a3811-120">То есть вновь сконструированный тип теперь отвечает за удаление объекта.</span><span class="sxs-lookup"><span data-stu-id="a3811-120">That is, the newly constructed type is now responsible for disposing of the object.</span></span> <span data-ttu-id="a3811-121">Если код передает в конструктор объект одного из этих типов, нарушение правила CA2000 не происходит, даже если объект не удален, прежде чем все ссылки на него выходят из области.</span><span class="sxs-lookup"><span data-stu-id="a3811-121">If your code passes an object of one of these types to a constructor, no violation of rule CA2000 occurs even if the object is not disposed before all references to it are out of scope.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="a3811-122">Устранение нарушений</span><span class="sxs-lookup"><span data-stu-id="a3811-122">How to fix violations</span></span>

<span data-ttu-id="a3811-123">Чтобы устранить нарушение этого правила, вызовите <xref:System.IDisposable.Dispose%2A> объект перед тем, как все ссылки на него выходят за пределы области.</span><span class="sxs-lookup"><span data-stu-id="a3811-123">To fix a violation of this rule, call <xref:System.IDisposable.Dispose%2A> on the object before all references to it are out of scope.</span></span>

<span data-ttu-id="a3811-124">Для создания оболочки объектов, реализующих, можно использовать [ `using` инструкцию](../../../csharp/language-reference/keywords/using-statement.md) ( [`Using`](../../../visual-basic/language-reference/statements/using-statement.md) в Visual Basic) <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="a3811-124">You can use the [`using` statement](../../../csharp/language-reference/keywords/using-statement.md) ([`Using`](../../../visual-basic/language-reference/statements/using-statement.md) in Visual Basic) to wrap objects that implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="a3811-125">Объекты, обтекаемые таким способом, автоматически удаляются в конце `using` блока.</span><span class="sxs-lookup"><span data-stu-id="a3811-125">Objects that are wrapped in this manner are automatically disposed at the end of the `using` block.</span></span> <span data-ttu-id="a3811-126">Однако следующие ситуации не должны обрабатываться `using` оператором:</span><span class="sxs-lookup"><span data-stu-id="a3811-126">However, the following situations should not or cannot be handled with a `using` statement:</span></span>

- <span data-ttu-id="a3811-127">Чтобы получить удаляемый объект, объект должен быть создан в `try/finally` блоке за пределами `using` блока.</span><span class="sxs-lookup"><span data-stu-id="a3811-127">To return a disposable object, the object must constructed in a `try/finally` block outside of a `using` block.</span></span>

- <span data-ttu-id="a3811-128">Не инициализируйте члены высвобождаемого объекта в конструкторе `using` инструкции.</span><span class="sxs-lookup"><span data-stu-id="a3811-128">Do not initialize members of a disposable object in the constructor of a `using` statement.</span></span>

- <span data-ttu-id="a3811-129">Если конструкторы, защищенные только одним обработчиком исключений, вложены в [ `using` инструкцию приобретения инструкции](../../../csharp/language-reference/keywords/using-statement.md), ошибка внешнего конструктора может привести к тому, что объект, созданный вложенным конструктором, никогда не закрывается.</span><span class="sxs-lookup"><span data-stu-id="a3811-129">When constructors that are protected by only one exception handler are nested in the [acquisition part of a `using` statement](../../../csharp/language-reference/keywords/using-statement.md), a failure in the outer constructor can result in the object created by the nested constructor never being closed.</span></span> <span data-ttu-id="a3811-130">В следующем примере сбой в <xref:System.IO.StreamReader> конструкторе может привести к тому, что <xref:System.IO.FileStream> объект никогда не закрывается.</span><span class="sxs-lookup"><span data-stu-id="a3811-130">In the following example, a failure in the <xref:System.IO.StreamReader> constructor can result in the <xref:System.IO.FileStream> object never being closed.</span></span> <span data-ttu-id="a3811-131">CA2000 помечает нарушение правила в этом случае.</span><span class="sxs-lookup"><span data-stu-id="a3811-131">CA2000 flags a violation of the rule in this case.</span></span>

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- <span data-ttu-id="a3811-132">Для реализации шаблона удаления объектов в динамических объектах следует использовать теневой объект <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="a3811-132">Dynamic objects should use a shadow object to implement the dispose pattern of <xref:System.IDisposable> objects.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="a3811-133">Когда следует подавлять предупреждения</span><span class="sxs-lookup"><span data-stu-id="a3811-133">When to suppress warnings</span></span>

<span data-ttu-id="a3811-134">Не отключайте предупреждение из этого правила, если:</span><span class="sxs-lookup"><span data-stu-id="a3811-134">Do not suppress a warning from this rule unless:</span></span>

- <span data-ttu-id="a3811-135">Вы вызвали метод для объекта, который вызывает `Dispose` , например <xref:System.IO.Stream.Close%2A></span><span class="sxs-lookup"><span data-stu-id="a3811-135">You've called a method on your object that calls `Dispose`, such as <xref:System.IO.Stream.Close%2A></span></span>
- <span data-ttu-id="a3811-136">Метод, вызвавший предупреждение, возвращает <xref:System.IDisposable> объект, который создает оболочку для объекта</span><span class="sxs-lookup"><span data-stu-id="a3811-136">The method that raised the warning returns an <xref:System.IDisposable> object that wraps your object</span></span>
- <span data-ttu-id="a3811-137">Метод выделения не имеет владельца. то есть, ответственность за удаление объекта передается в другой объект или оболочку, которая создается в методе и возвращается вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="a3811-137">The allocating method does not have dispose ownership; that is, the responsibility to dispose the object is transferred to another object or wrapper that's created in the method and returned to the caller</span></span>

## <a name="configure-code-to-analyze"></a><span data-ttu-id="a3811-138">Настройка анализируемого кода</span><span class="sxs-lookup"><span data-stu-id="a3811-138">Configure code to analyze</span></span>

<span data-ttu-id="a3811-139">Используйте следующие параметры, чтобы настроить, на какие части базы кода следует запускать это правило.</span><span class="sxs-lookup"><span data-stu-id="a3811-139">Use the following options to configure which parts of your codebase to run this rule on.</span></span>

- [<span data-ttu-id="a3811-140">Исключить конкретные символы</span><span class="sxs-lookup"><span data-stu-id="a3811-140">Exclude specific symbols</span></span>](#exclude-specific-symbols)
- [<span data-ttu-id="a3811-141">Исключить определенные типы и их производные типы</span><span class="sxs-lookup"><span data-stu-id="a3811-141">Exclude specific types and their derived types</span></span>](#exclude-specific-types-and-their-derived-types)

<span data-ttu-id="a3811-142">Эти параметры можно настроить только для этого правила, для всех правил или для всех правил в этой категории ([надежность](reliability-warnings.md)).</span><span class="sxs-lookup"><span data-stu-id="a3811-142">You can configure these options for just this rule, for all rules, or for all rules in this category ([Reliability](reliability-warnings.md)).</span></span> <span data-ttu-id="a3811-143">Дополнительные сведения см. в разделе [Параметры конфигурации правила качества кода](../code-quality-rule-options.md).</span><span class="sxs-lookup"><span data-stu-id="a3811-143">For more information, see [Code quality rule configuration options](../code-quality-rule-options.md).</span></span>

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="related-rules"></a><span data-ttu-id="a3811-144">Связанные правила</span><span class="sxs-lookup"><span data-stu-id="a3811-144">Related rules</span></span>

- [<span data-ttu-id="a3811-145">CA2213. Следует высвобождать высвобождаемые поля</span><span class="sxs-lookup"><span data-stu-id="a3811-145">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)

## <a name="example-1"></a><span data-ttu-id="a3811-146">Пример 1</span><span class="sxs-lookup"><span data-stu-id="a3811-146">Example 1</span></span>

<span data-ttu-id="a3811-147">При реализации метода, возвращающего удаляемый объект, используйте блок try/finally без блока catch, чтобы убедиться, что объект удален.</span><span class="sxs-lookup"><span data-stu-id="a3811-147">If you're implementing a method that returns a disposable object, use a try/finally block without a catch block to make sure that the object is disposed.</span></span> <span data-ttu-id="a3811-148">С помощью блока try/finally можно разрешать возникновение исключений в точке сбоя и убедиться, что объект удален.</span><span class="sxs-lookup"><span data-stu-id="a3811-148">By using a try/finally block, you allow exceptions to be raised at the fault point and make sure that object is disposed.</span></span>

<span data-ttu-id="a3811-149">В методе OpenPort1 вызов для открытия объекта ISerializable SerialPort или вызова SomeMethod может завершиться ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3811-149">In the OpenPort1 method, the call to open the ISerializable object SerialPort or the call to SomeMethod can fail.</span></span> <span data-ttu-id="a3811-150">В этой реализации возникает предупреждение CA2000.</span><span class="sxs-lookup"><span data-stu-id="a3811-150">A CA2000 warning is raised on this implementation.</span></span>

<span data-ttu-id="a3811-151">В методе OpenPort2 объявляются два объекта SerialPort и устанавливается в значение NULL:</span><span class="sxs-lookup"><span data-stu-id="a3811-151">In the OpenPort2 method, two SerialPort objects are declared and set to null:</span></span>

- <span data-ttu-id="a3811-152">`tempPort`, который используется для проверки успешности выполнения операций метода.</span><span class="sxs-lookup"><span data-stu-id="a3811-152">`tempPort`, which is used to test that the method operations succeed.</span></span>

- <span data-ttu-id="a3811-153">`port`, который используется для возвращаемого значения метода.</span><span class="sxs-lookup"><span data-stu-id="a3811-153">`port`, which is used for the return value of the method.</span></span>

<span data-ttu-id="a3811-154">Объект `tempPort` создается и открывается в `try` блоке, и любая другая требуемая работа выполняется в том же `try` блоке.</span><span class="sxs-lookup"><span data-stu-id="a3811-154">The `tempPort` is constructed and opened in a `try` block, and any other required work is performed in the same `try` block.</span></span> <span data-ttu-id="a3811-155">В конце `try` блока открытый порт назначается `port` объекту, который будет возвращен, и `tempPort` для объекта задается значение `null` .</span><span class="sxs-lookup"><span data-stu-id="a3811-155">At the end of the `try` block, the opened port is assigned to the `port` object that will be returned and the `tempPort` object is set to `null`.</span></span>

<span data-ttu-id="a3811-156">`finally`Блок проверяет значение `tempPort` .</span><span class="sxs-lookup"><span data-stu-id="a3811-156">The `finally` block checks the value of `tempPort`.</span></span> <span data-ttu-id="a3811-157">Если это значение не равно null, операция в методе завершилась неудачно и `tempPort` закрыта, чтобы убедиться, что все ресурсы освобождены.</span><span class="sxs-lookup"><span data-stu-id="a3811-157">If it is not null, an operation in the method has failed, and `tempPort` is closed to make sure that any resources are released.</span></span> <span data-ttu-id="a3811-158">Возвращенный объект порта будет содержать открытый объект SerialPort, если операции метода завершились успешно, или значение null, если операция завершилась ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3811-158">The returned port object will contain the opened SerialPort object if the operations of the method succeeded, or it will be null if an operation failed.</span></span>

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example-2"></a><span data-ttu-id="a3811-159">Пример 2</span><span class="sxs-lookup"><span data-stu-id="a3811-159">Example 2</span></span>

<span data-ttu-id="a3811-160">По умолчанию компилятор Visual Basic имеет все арифметические операторы, которые проверяют переполнение.</span><span class="sxs-lookup"><span data-stu-id="a3811-160">By default, the Visual Basic compiler has all arithmetic operators check for overflow.</span></span> <span data-ttu-id="a3811-161">Таким образом, любая Visual Basic арифметическая операция может вызвать исключение <xref:System.OverflowException> .</span><span class="sxs-lookup"><span data-stu-id="a3811-161">Therefore, any Visual Basic arithmetic operation might throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="a3811-162">Это может привести к непредвиденным нарушениям правил, таких как CA2000.</span><span class="sxs-lookup"><span data-stu-id="a3811-162">This could lead to unexpected violations in rules such as CA2000.</span></span> <span data-ttu-id="a3811-163">Например, следующая функция CreateReader1 выдаст нарушение CA2000, так как компилятор Visual Basic выдает инструкцию проверки переполнения для добавления, которая может вызвать исключение, которое привело бы к удалению StreamReader.</span><span class="sxs-lookup"><span data-stu-id="a3811-163">For example, the following CreateReader1 function will produce a CA2000 violation because the Visual Basic compiler is emitting an overflow checking instruction for the addition that could throw an exception that would cause the StreamReader not to be disposed.</span></span>

<span data-ttu-id="a3811-164">Чтобы устранить эту проблему, можно отключить эмиссию проверок переполнения компилятором Visual Basic в проекте или изменить код, как в следующей функции CreateReader2.</span><span class="sxs-lookup"><span data-stu-id="a3811-164">To fix this, you can disable the emitting of overflow checks by the Visual Basic compiler in your project or you can modify your code as in the following CreateReader2 function.</span></span>

<span data-ttu-id="a3811-165">Чтобы отключить эмиссию проверок переполнения, щелкните правой кнопкой мыши имя проекта в обозреватель решений а затем выберите пункт **Свойства**.</span><span class="sxs-lookup"><span data-stu-id="a3811-165">To disable the emitting of overflow checks, right-click the project name in Solution Explorer and then click **Properties**.</span></span> <span data-ttu-id="a3811-166">Нажмите кнопку **компилировать**, щелкните **Дополнительные параметры компиляции**, а затем установите флажок **Удалить проверки переполнения целых чисел**.</span><span class="sxs-lookup"><span data-stu-id="a3811-166">Click **Compile**, click **Advanced Compile Options**, and then check **Remove integer overflow checks**.</span></span>

:::code language="vb" source="snippets/vb/all-rules/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb":::

## <a name="see-also"></a><span data-ttu-id="a3811-167">См. также</span><span class="sxs-lookup"><span data-stu-id="a3811-167">See also</span></span>

- <xref:System.IDisposable>
- [<span data-ttu-id="a3811-168">Шаблон ликвидации</span><span class="sxs-lookup"><span data-stu-id="a3811-168">Dispose Pattern</span></span>](../../../standard/garbage-collection/implementing-dispose.md)
