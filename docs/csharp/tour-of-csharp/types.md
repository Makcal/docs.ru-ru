---
title: Определение типов и их элементов — обзор C#
description: Типы — это стандартные блоки, из которых состоят программы. Узнайте, как создавать классы, структуры, интерфейсы и многое другое в C#.
ms.date: 08/06/2020
ms.openlocfilehash: b1ce24611fec6fdf01d5ecb8d6ae974e147c78c5
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216607"
---
# <a name="types-and-members"></a><span data-ttu-id="e1166-104">Типы и элементы</span><span class="sxs-lookup"><span data-stu-id="e1166-104">Types and members</span></span>

<span data-ttu-id="e1166-105">C# является объектно-ориентированным языком, а значит поддерживает инкапсуляцию, наследование и полиморфизм.</span><span class="sxs-lookup"><span data-stu-id="e1166-105">As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.</span></span> <span data-ttu-id="e1166-106">Класс наследуется непосредственно из одного родительского класса. Он может реализовывать любое число интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e1166-106">A class may inherit directly from one parent class, and it may implement any number of interfaces.</span></span> <span data-ttu-id="e1166-107">Методы, которые переопределяют виртуальные методы родительского класса, должны содержать ключевое слово `override`, чтобы исключить случайное переопределение.</span><span class="sxs-lookup"><span data-stu-id="e1166-107">Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.</span></span> <span data-ttu-id="e1166-108">В языке C# структура похожа на облегченный класс: это тип, распределяемый в стеке и реализующий интерфейсы, но не поддерживающий наследование.</span><span class="sxs-lookup"><span data-stu-id="e1166-108">In C#, a struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance.</span></span> <span data-ttu-id="e1166-109">C# также предоставляет записи. Запись — это тип класса, основное назначение которого заключается в хранении данных.</span><span class="sxs-lookup"><span data-stu-id="e1166-109">C# also provides records, which are class types whose purpose is primarily storing data values.</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="e1166-110">Классы и объекты</span><span class="sxs-lookup"><span data-stu-id="e1166-110">Classes and objects</span></span>

<span data-ttu-id="e1166-111">*Классы* являются основным типом в языке C#.</span><span class="sxs-lookup"><span data-stu-id="e1166-111">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="e1166-112">Класс представляет собой структуру данных, которая объединяет в себе значения (поля) и действия (методы и другие функции-члены).</span><span class="sxs-lookup"><span data-stu-id="e1166-112">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="e1166-113">Класс предоставляет определение для *экземпляров* класса, которые также именуются *объектами*.</span><span class="sxs-lookup"><span data-stu-id="e1166-113">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="e1166-114">Классы поддерживают механизмы *наследования* и *полиморфизма*, которые позволяют создавать *производные классы*, расширяющие и уточняющие определения *базовых классов*.</span><span class="sxs-lookup"><span data-stu-id="e1166-114">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="e1166-115">Новые классы создаются с помощью объявлений классов.</span><span class="sxs-lookup"><span data-stu-id="e1166-115">New classes are created using class declarations.</span></span> <span data-ttu-id="e1166-116">Объявление класса начинается с заголовка.</span><span class="sxs-lookup"><span data-stu-id="e1166-116">A class declaration starts with a header.</span></span> <span data-ttu-id="e1166-117">Заголовок указывает:</span><span class="sxs-lookup"><span data-stu-id="e1166-117">The header specifies:</span></span>

- <span data-ttu-id="e1166-118">Атрибуты и модификаторы класса</span><span class="sxs-lookup"><span data-stu-id="e1166-118">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="e1166-119">Имя класса</span><span class="sxs-lookup"><span data-stu-id="e1166-119">The name of the class</span></span>
- <span data-ttu-id="e1166-120">Базовый класс (при наследовании от [базового класса](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="e1166-120">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="e1166-121">Интерфейсы, реализуемые классом.</span><span class="sxs-lookup"><span data-stu-id="e1166-121">The interfaces implemented by the class.</span></span>

<span data-ttu-id="e1166-122">За заголовком между разделителями `{` и `}` следует тело класса, в котором последовательно объявляются все члены класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-122">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="e1166-123">Следующий код является простым примером объявления класса с именем `Point`:</span><span class="sxs-lookup"><span data-stu-id="e1166-123">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="e1166-124">Экземпляры классов создаются с помощью оператора `new`, который выделяет память для нового экземпляра, вызывает конструктор для инициализации этого экземпляра и возвращает ссылку на экземпляр.</span><span class="sxs-lookup"><span data-stu-id="e1166-124">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="e1166-125">Следующие инструкции создают два объекта `Point` и сохраняют ссылки на эти объекты в двух переменных:</span><span class="sxs-lookup"><span data-stu-id="e1166-125">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="e1166-126">Занимаемая объектом память автоматически освобождается, когда объект становится недоступен.</span><span class="sxs-lookup"><span data-stu-id="e1166-126">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="e1166-127">В C# нет ни необходимости, ни возможности освобождать память объектов явным образом.</span><span class="sxs-lookup"><span data-stu-id="e1166-127">It's not necessary or possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="e1166-128">Параметры типа</span><span class="sxs-lookup"><span data-stu-id="e1166-128">Type parameters</span></span>

<span data-ttu-id="e1166-129">Универсальные классы определяют [\***параметры типа** _](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="e1166-129">Generic classes define [\***type parameters** _](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="e1166-130">Параметры типа — это список имен параметров типа, заключенных в угловые скобки.</span><span class="sxs-lookup"><span data-stu-id="e1166-130">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="e1166-131">Параметры типа следуют за именем класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-131">Type parameters follow the class name.</span></span> <span data-ttu-id="e1166-132">Параметры типа можно использовать в теле класса в определениях, описывающих члены класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-132">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="e1166-133">В следующем примере для класса `Pair` заданы параметры типа `TFirst` и `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="e1166-133">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="e1166-134">Тип класса, для которого объявлены параметры типа, называется _универсальным типом класса\*.</span><span class="sxs-lookup"><span data-stu-id="e1166-134">A class type that is declared to take type parameters is called a _generic class type\*.</span></span> <span data-ttu-id="e1166-135">Типы структуры, интерфейса и делегата также могут быть универсальными.</span><span class="sxs-lookup"><span data-stu-id="e1166-135">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="e1166-136">Если вы используете универсальный класс, необходимо указать аргумент типа для каждого параметра типа, вот так:</span><span class="sxs-lookup"><span data-stu-id="e1166-136">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="e1166-137">Универсальный тип, для которого указаны аргументы типа, как `Pair<int,string>` в примере выше, называется *сконструированным типом*.</span><span class="sxs-lookup"><span data-stu-id="e1166-137">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="e1166-138">базовых классов;</span><span class="sxs-lookup"><span data-stu-id="e1166-138">Base classes</span></span>

<span data-ttu-id="e1166-139">В объявлении класса может быть указан базовый класс.</span><span class="sxs-lookup"><span data-stu-id="e1166-139">A class declaration may specify a base class.</span></span> <span data-ttu-id="e1166-140">Имя базового класса указывается после имени класса и параметров типа и отделяется от них двоеточием.</span><span class="sxs-lookup"><span data-stu-id="e1166-140">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="e1166-141">Если спецификация базового класса не указана, класс наследуется от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="e1166-141">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="e1166-142">В следующем примере `Point3D` имеет базовый класс `Point`.</span><span class="sxs-lookup"><span data-stu-id="e1166-142">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="e1166-143">В первом примере `Point` имеет базовый класс `object`:</span><span class="sxs-lookup"><span data-stu-id="e1166-143">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="e1166-144">Класс наследует члены базового класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-144">A class inherits the members of its base class.</span></span> <span data-ttu-id="e1166-145">Наследование означает, что класс неявно содержит почти все элементы базового класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-145">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="e1166-146">Класс не наследует экземпляры, статические конструкторы и метод завершения.</span><span class="sxs-lookup"><span data-stu-id="e1166-146">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="e1166-147">Производный класс может добавлять новые члены к наследуемым, но не может удалить определение для наследуемого члена.</span><span class="sxs-lookup"><span data-stu-id="e1166-147">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="e1166-148">В предыдущем примере `Point3D` наследует члены `X` и `Y` из `Point`, и каждый экземпляр `Point3D` содержит три свойства: `X`, `Y` и `Z`.</span><span class="sxs-lookup"><span data-stu-id="e1166-148">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="e1166-149">Используется неявное преобразование из типа класса к любому из типов соответствующего базового класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-149">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="e1166-150">Переменная типа класса может ссылаться как на экземпляр этого класса, так и на экземпляры любого производного класса.</span><span class="sxs-lookup"><span data-stu-id="e1166-150">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="e1166-151">Например, если мы используем описанные выше объявления классов, то переменная типа `Point` может ссылаться на `Point` или `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="e1166-151">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="e1166-152">Структуры</span><span class="sxs-lookup"><span data-stu-id="e1166-152">Structs</span></span>

<span data-ttu-id="e1166-153">Классы определяют типы, поддерживающие наследование и полиморфизм.</span><span class="sxs-lookup"><span data-stu-id="e1166-153">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="e1166-154">Они позволяют создавать сложные расширения функциональности на основе иерархий производных классов.</span><span class="sxs-lookup"><span data-stu-id="e1166-154">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="e1166-155">В отличие от них, типы [\***struct** _](../language-reference/builtin-types/struct.md) — это простые типы, основное назначение которых — хранить значения данных.</span><span class="sxs-lookup"><span data-stu-id="e1166-155">By contrast, [\***struct** _](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="e1166-156">В структурах не может быть объявлен базовый тип; они неявно наследуются от <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1166-156">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1166-157">От типа `struct` не могут быть унаследованы другие типы `struct`.</span><span class="sxs-lookup"><span data-stu-id="e1166-157">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="e1166-158">Они неявно запечатаны.</span><span class="sxs-lookup"><span data-stu-id="e1166-158">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="e1166-159">интерфейсов,</span><span class="sxs-lookup"><span data-stu-id="e1166-159">Interfaces</span></span>

<span data-ttu-id="e1166-160">[_\*_Интерфейс_\*_](../programming-guide/interfaces/index.md) определяет контракт, который может быть реализован классами и структурами.</span><span class="sxs-lookup"><span data-stu-id="e1166-160">An [_*_interface_*_](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="e1166-161">Интерфейс может содержать методы, свойства, события и индексаторы.</span><span class="sxs-lookup"><span data-stu-id="e1166-161">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="e1166-162">Интерфейс обычно не предоставляет реализацию элементов, которые в нем определены. Он лишь перечисляет элементы, которые должны быть определены в классах или структурах, реализующих этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e1166-162">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="e1166-163">Интерфейсы могут применять _\*_множественное наследование_\*_.</span><span class="sxs-lookup"><span data-stu-id="e1166-163">Interfaces may employ _*_multiple inheritance_*_.</span></span> <span data-ttu-id="e1166-164">В следующем примере интерфейс `IComboBox` наследует одновременно от `ITextBox` и `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="e1166-164">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="e1166-165">Классы и структуры могут реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e1166-165">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="e1166-166">В следующем примере класс `EditBox` реализует одновременно `IControl` и `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="e1166-166">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="e1166-167">Если класс или структура реализует конкретный интерфейс, любой экземпляр этого класса или структуры можно неявно преобразовать в такой тип интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e1166-167">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="e1166-168">Например.</span><span class="sxs-lookup"><span data-stu-id="e1166-168">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="e1166-169">Перечисления</span><span class="sxs-lookup"><span data-stu-id="e1166-169">Enums</span></span>

<span data-ttu-id="e1166-170">Тип [_*_Enum_*_](../language-reference/builtin-types/enum.md) определяет набор константных значений.</span><span class="sxs-lookup"><span data-stu-id="e1166-170">An [_*_Enum_*_](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="e1166-171">В следующем объявлении `enum` определяются константы, соответствующие различным корнеплодам:</span><span class="sxs-lookup"><span data-stu-id="e1166-171">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="e1166-172">Также можно определить `enum`, которое будет использоваться в виде сочетания флагов.</span><span class="sxs-lookup"><span data-stu-id="e1166-172">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="e1166-173">В следующем объявлении определяется набор флагов для четырех времен года.</span><span class="sxs-lookup"><span data-stu-id="e1166-173">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="e1166-174">Можно применить любое сочетание времен года, в том числе значение `All`, включающее все времена года:</span><span class="sxs-lookup"><span data-stu-id="e1166-174">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="e1166-175">В следующем примере показаны объявления для обоих указанных выше перечислений:</span><span class="sxs-lookup"><span data-stu-id="e1166-175">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="e1166-176">Типы, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="e1166-176">Nullable types</span></span>

<span data-ttu-id="e1166-177">Переменные любого типа могут быть объявлены как _\*_не допускающие значение NULL_*_ или _*_допускающие значение NULL_\*_.</span><span class="sxs-lookup"><span data-stu-id="e1166-177">Variables of any type may be declared as _*_non-nullable_*_ or _*_nullable_*_.</span></span> <span data-ttu-id="e1166-178">Переменная, допускающая значение NULL, может содержать дополнительное значение `null`, указывающее на отсутствие значения.</span><span class="sxs-lookup"><span data-stu-id="e1166-178">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="e1166-179">Типы значений, допускающие значение NULL (структуры или перечисления), представляются <xref:System.Nullable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e1166-179">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1166-180">Ссылочные типы, не допускающие значение NULL и допускающие значение NULL, представляются базовым ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="e1166-180">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="e1166-181">Различие представляется метаданными, которые считываются компилятором и некоторыми библиотеками.</span><span class="sxs-lookup"><span data-stu-id="e1166-181">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="e1166-182">Если ссылки, допускающие значение NULL, разыменовываются без предварительной проверки значения на `null`, компилятор выдает предупреждения.</span><span class="sxs-lookup"><span data-stu-id="e1166-182">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="e1166-183">Компилятор также выдает предупреждения, если ссылкам, не допускающим значение NULL, присваивается значение, которое может быть равно `null`.</span><span class="sxs-lookup"><span data-stu-id="e1166-183">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="e1166-184">В следующем примере объявляется _\*_переменная целочисленного типа, допускающая значение NULL_\*_, и эта переменная инициализируется значением `null`.</span><span class="sxs-lookup"><span data-stu-id="e1166-184">The following example declares a _*_nullable int_*_, initializing it to `null`.</span></span> <span data-ttu-id="e1166-185">Затем ей присваивается значение `5`.</span><span class="sxs-lookup"><span data-stu-id="e1166-185">Then, it sets the value to `5`.</span></span> <span data-ttu-id="e1166-186">Затем те же действия выполняются для _\*_строки, допускающей значение NULL_\*_.</span><span class="sxs-lookup"><span data-stu-id="e1166-186">It demonstrates the same concept with a _*_nullable string_*_.</span></span> <span data-ttu-id="e1166-187">Дополнительные сведения см. в статьях [Типы значений, допускающие значение NULL](../language-reference/builtin-types/nullable-value-types.md) и [Ссылочные типы, допускающие значение NULL](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="e1166-187">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="e1166-188">Кортежи</span><span class="sxs-lookup"><span data-stu-id="e1166-188">Tuples</span></span>

<span data-ttu-id="e1166-189">C# поддерживает [_ *_кортежи_*\*](../language-reference/builtin-types/value-tuples.md), которые предоставляют краткий синтаксис для группирования нескольких элементов данных в упрощенную структуру данных.</span><span class="sxs-lookup"><span data-stu-id="e1166-189">C# supports [_ *_tuples_*\*](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="e1166-190">Чтобы создать экземпляр кортежа, необходимо объявить типы и имена элементов между `(` и `)`, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="e1166-190">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="e1166-191">Кортежи являются альтернативой для структуры данных с несколькими элементами. В них не используются стандартные блоки, описанные в следующей статье.</span><span class="sxs-lookup"><span data-stu-id="e1166-191">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e1166-192">[Назад](index.md)
>[Вперед](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="e1166-192">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
