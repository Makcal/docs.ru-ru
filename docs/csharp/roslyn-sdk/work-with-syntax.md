---
title: Использование модели синтаксиса пакета SDK для .NET Compiler Platform
description: Данный обзор описывает типы, используемые для получения сведений о синтаксических узлах и управления ими.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: 3666b0ec875b465954780c3c313ca87c9a4e6676
ms.sourcegitcommit: 8299abfbd5c49b596d61f1e4d09bc6b8ba055b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/27/2021
ms.locfileid: "98899143"
---
# <a name="work-with-syntax"></a><span data-ttu-id="1c484-103">Работа с синтаксисом</span><span class="sxs-lookup"><span data-stu-id="1c484-103">Work with syntax</span></span>

<span data-ttu-id="1c484-104">*Дерево синтаксиса* представляет собой базовую неизменяемую структуру данных, предоставляемую API компилятора.</span><span class="sxs-lookup"><span data-stu-id="1c484-104">The *syntax tree* is a fundamental immutable data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="1c484-105">Эти деревья представляют лексическую и синтаксическую структуру исходного кода.</span><span class="sxs-lookup"><span data-stu-id="1c484-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="1c484-106">Они служат для двух важных целей:</span><span class="sxs-lookup"><span data-stu-id="1c484-106">They serve two important purposes:</span></span>

- <span data-ttu-id="1c484-107">Чтобы позволить средствам, таким как интегрированная среда разработки, надстройки, средства анализа кода и рефакторинг, просматривать и обрабатывать синтаксическую структуру исходного кода в проекте пользователя.</span><span class="sxs-lookup"><span data-stu-id="1c484-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user's project.</span></span>
- <span data-ttu-id="1c484-108">Чтобы позволить средствам, таким как рефакторинг и интегрированная среда разработки, создавать, изменять и переупорядочивать исходный код естественным образом без прямых изменений текста.</span><span class="sxs-lookup"><span data-stu-id="1c484-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="1c484-109">Создавая деревья и управляя ими, средства легко могут создавать и переупорядочивать исходный код.</span><span class="sxs-lookup"><span data-stu-id="1c484-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="1c484-110">Деревья синтаксиса</span><span class="sxs-lookup"><span data-stu-id="1c484-110">Syntax trees</span></span>

<span data-ttu-id="1c484-111">Деревья синтаксиса образуют первичную структуру, используемую для компиляции, анализа кода, привязки, рефакторинга, функций интегрированной среды разработки и создания кода.</span><span class="sxs-lookup"><span data-stu-id="1c484-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="1c484-112">Любая часть исходного кода становится понятной только после того, как будет идентифицирована и классифицирована по одному из многих известных структурных элементов языка.</span><span class="sxs-lookup"><span data-stu-id="1c484-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="1c484-113">Деревья синтаксиса имеют три ключевых атрибута.</span><span class="sxs-lookup"><span data-stu-id="1c484-113">Syntax trees have three key attributes:</span></span>

- <span data-ttu-id="1c484-114">Они хранят всю информацию об источнике во всей ее полной точности.</span><span class="sxs-lookup"><span data-stu-id="1c484-114">They hold all the source information in full fidelity.</span></span> <span data-ttu-id="1c484-115">Полная точность означает, что дерево синтаксиса содержит всю информацию, отраженную в исходном тексте, каждую грамматическую конструкцию, каждую лексему, а также все промежуточные элементы, включая пробелы, комментарии и директивы препроцессора.</span><span class="sxs-lookup"><span data-stu-id="1c484-115">Full fidelity means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="1c484-116">Например, каждый упомянутый в исходном коде литерал представлен точно так, как был указан.</span><span class="sxs-lookup"><span data-stu-id="1c484-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="1c484-117">Деревья синтаксиса также перехватывают ошибки в исходном коде, если программа является неполной или неправильно сформированной из-за пропущенных или отсутствующих токенов.</span><span class="sxs-lookup"><span data-stu-id="1c484-117">Syntax trees also capture errors in source code when the program is incomplete or malformed by representing skipped or missing tokens.</span></span>
- <span data-ttu-id="1c484-118">С их помощью можно создать точный текст, из которого они были сформированы.</span><span class="sxs-lookup"><span data-stu-id="1c484-118">They can produce the exact text that they were parsed from.</span></span> <span data-ttu-id="1c484-119">От любого синтаксического узла можно получить текстовое представление поддерева, корнем которого он является.</span><span class="sxs-lookup"><span data-stu-id="1c484-119">From any syntax node, it's possible to get the text representation of the subtree rooted at that node.</span></span> <span data-ttu-id="1c484-120">Такая возможность означает, что деревья синтаксиса можно использовать для создания и изменения текста исходного кода.</span><span class="sxs-lookup"><span data-stu-id="1c484-120">This ability means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="1c484-121">Создавая дерево, вы косвенно создаете эквивалентный текст, а получая новое дерево на основе изменений существующего, вы фактически редактируете текст.</span><span class="sxs-lookup"><span data-stu-id="1c484-121">By creating a tree you have, by implication, created the equivalent text, and by making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>
- <span data-ttu-id="1c484-122">Они являются неизменяемыми и потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="1c484-122">They are immutable and thread-safe.</span></span> <span data-ttu-id="1c484-123">После получения дерево представляет собой моментальный снимок текущего состояния кода и никогда не меняется.</span><span class="sxs-lookup"><span data-stu-id="1c484-123">After a tree is obtained, it's a snapshot of the current state of the code and never changes.</span></span> <span data-ttu-id="1c484-124">Это позволяет нескольким пользователям одновременно взаимодействовать с одним деревом синтаксиса в разных потоках без блокировки или дублирования.</span><span class="sxs-lookup"><span data-stu-id="1c484-124">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="1c484-125">Так как деревья являются неизменяемыми, то есть напрямую в них невозможно внести никакие изменения, фабричные методы помогают создавать и изменять деревья синтаксиса путем создания их дополнительных снимков.</span><span class="sxs-lookup"><span data-stu-id="1c484-125">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="1c484-126">Деревья эффективно используют базовые узлы повторно, поэтому новую версию можно перестроить быстро и с небольшими затратами памяти.</span><span class="sxs-lookup"><span data-stu-id="1c484-126">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="1c484-127">Дерево синтаксиса фактически является древовидной структурой данных, где нетерминальные структурные элементы являются родительскими для других элементов.</span><span class="sxs-lookup"><span data-stu-id="1c484-127">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="1c484-128">Каждое дерево синтаксиса состоит из узлов, токенов и дополнительной синтаксической информации (trivia).</span><span class="sxs-lookup"><span data-stu-id="1c484-128">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="1c484-129">Синтаксические узлы</span><span class="sxs-lookup"><span data-stu-id="1c484-129">Syntax nodes</span></span>

<span data-ttu-id="1c484-130">Синтаксические узлы являются одним из основных элементов деревьев синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="1c484-130">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="1c484-131">Они представляют такие синтаксические конструкции, как объявления, операторы, предложения и выражения.</span><span class="sxs-lookup"><span data-stu-id="1c484-131">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="1c484-132">Каждая категория синтаксических узлов представлена отдельным классом, производным от <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1c484-132">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1c484-133">Набор классов узлов не является расширяемым.</span><span class="sxs-lookup"><span data-stu-id="1c484-133">The set of node classes is not extensible.</span></span>

<span data-ttu-id="1c484-134">Все синтаксические узлы являются нетерминальными узлами в дереве синтаксиса, значит, всегда имеют дочерние элементы в виде других узлов и токенов.</span><span class="sxs-lookup"><span data-stu-id="1c484-134">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="1c484-135">Как дочерний элемент другого узла каждый узел имеет родительский узел, к которому можно обратиться с помощью свойства <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1c484-135">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1c484-136">Так как узлы и деревья являются неизменяемыми, родительский элемент узла никогда не меняется.</span><span class="sxs-lookup"><span data-stu-id="1c484-136">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="1c484-137">Корень дерева имеет родительский элемент null.</span><span class="sxs-lookup"><span data-stu-id="1c484-137">The root of the tree has a null parent.</span></span>

<span data-ttu-id="1c484-138">Каждый узел имеет метод <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, возвращающий список дочерних узлов в последовательном порядке с учетом их позиции в тексте исходного кода.</span><span class="sxs-lookup"><span data-stu-id="1c484-138">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="1c484-139">Этот список не содержит токены.</span><span class="sxs-lookup"><span data-stu-id="1c484-139">This list does not contain tokens.</span></span> <span data-ttu-id="1c484-140">Каждый узел также имеет методы для изучения дочерних объектов, такие как <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> или <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A>. Они представляют список всех узлов, токенов или дополнительной синтаксической информации, которые присутствуют в поддереве, являющемся корнем этого узла.</span><span class="sxs-lookup"><span data-stu-id="1c484-140">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the subtree rooted by that node.</span></span>

<span data-ttu-id="1c484-141">Кроме того, каждый подкласс синтаксических узлов предоставляет те же дочерние элементы посредством строго типизированных свойств.</span><span class="sxs-lookup"><span data-stu-id="1c484-141">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="1c484-142">Например, класс узлов <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> имеет три дополнительные свойства для отдельных бинарных операторов: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="1c484-142">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="1c484-143">Типом <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> является <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, а типом <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> — <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="1c484-143">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="1c484-144">Некоторые синтаксические узлы имеют дополнительные дочерние элементы.</span><span class="sxs-lookup"><span data-stu-id="1c484-144">Some syntax nodes have optional children.</span></span> <span data-ttu-id="1c484-145">Например, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> имеет дополнительный <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="1c484-145">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="1c484-146">Если дочерний элемент не указан, свойство возвращает значение null.</span><span class="sxs-lookup"><span data-stu-id="1c484-146">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="1c484-147">Синтаксические токены</span><span class="sxs-lookup"><span data-stu-id="1c484-147">Syntax tokens</span></span>

<span data-ttu-id="1c484-148">Синтаксические токены являются терминалами грамматики языка, представляющими наименьшие синтаксические фрагменты кода.</span><span class="sxs-lookup"><span data-stu-id="1c484-148">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="1c484-149">Они никогда не бывают родителями других узлов или токенов.</span><span class="sxs-lookup"><span data-stu-id="1c484-149">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="1c484-150">Синтаксические токены состоят из ключевых слов, идентификаторов, литералов и знаков препинания.</span><span class="sxs-lookup"><span data-stu-id="1c484-150">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="1c484-151">Для повышения эффективности тип <xref:Microsoft.CodeAnalysis.SyntaxToken> является типом значений среды CLR.</span><span class="sxs-lookup"><span data-stu-id="1c484-151">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="1c484-152">Таким образом, в отличие от синтаксических узлов существует всего одна структура для всех видов токенов с набором свойств, значение которых зависит от типа представленного токена.</span><span class="sxs-lookup"><span data-stu-id="1c484-152">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="1c484-153">Например, токен целочисленного литерала представляет числовое значение.</span><span class="sxs-lookup"><span data-stu-id="1c484-153">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="1c484-154">Кроме необработанного текста исходного кода, охватываемого токеном, токен литерала имеет свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, сообщающее точное декодированное целочисленное значение.</span><span class="sxs-lookup"><span data-stu-id="1c484-154">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="1c484-155">Это свойство имеет тип <xref:System.Object>, так как может быть одним из многих типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="1c484-155">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="1c484-156">Свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> сообщает те же сведения, что и свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, однако оно всегда имеет тип <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="1c484-156">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="1c484-157">Идентификатор в тексте исходного кода C# может включать escape-символы Юникода, при этом синтаксис самой escape-последовательности не считается частью имени идентификатора.</span><span class="sxs-lookup"><span data-stu-id="1c484-157">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="1c484-158">Поэтому хотя охватываемый токеном необработанный текст и включает escape-последовательность, свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> ее не содержит.</span><span class="sxs-lookup"><span data-stu-id="1c484-158">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="1c484-159">Вместо этого оно включает в себя символы Юникода, определяемые этой escape-последовательностью.</span><span class="sxs-lookup"><span data-stu-id="1c484-159">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="1c484-160">Например, если текст исходного кода содержит идентификатор, записанный как `\u03C0`, то свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> для этого токена возвратит `π`.</span><span class="sxs-lookup"><span data-stu-id="1c484-160">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="1c484-161">Дополнительная синтаксическая информация</span><span class="sxs-lookup"><span data-stu-id="1c484-161">Syntax trivia</span></span>

<span data-ttu-id="1c484-162">Дополнительная синтаксическая информация (syntax trivia) представляет части текста в исходном коде, которые очень мало влияют на понимание кода, например пробелы, комментарии и директивы препроцессора.</span><span class="sxs-lookup"><span data-stu-id="1c484-162">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="1c484-163">Как и синтаксические токены, элементы trivia являются типами значений.</span><span class="sxs-lookup"><span data-stu-id="1c484-163">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="1c484-164">Для описания всех видов trivia используется один тип <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1c484-164">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="1c484-165">Так как элементы trivia не являются частью обычного синтаксиса и могут стоять в любом месте между двумя любыми токенами, они не включаются в дерево синтаксиса в качестве дочернего элемента узла.</span><span class="sxs-lookup"><span data-stu-id="1c484-165">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="1c484-166">Хотя, так как они важны при реализации таких функций, как рефакторинг, и обеспечения полного соответствия тексту исходного кода, они входят в состав дерева синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="1c484-166">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="1c484-167">Вы можете обратиться к trivia, просмотрев коллекции <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> или <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> токена.</span><span class="sxs-lookup"><span data-stu-id="1c484-167">You can access trivia by inspecting a token's <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="1c484-168">При синтаксическом анализе текста исходного кода последовательности trivia сопоставляются с токенами.</span><span class="sxs-lookup"><span data-stu-id="1c484-168">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="1c484-169">Как правило, токену принадлежит любой элемент trivia, расположенный в той же строке до следующего токена.</span><span class="sxs-lookup"><span data-stu-id="1c484-169">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="1c484-170">Любой элемент trivia после этой строки сопоставляется со следующим токеном.</span><span class="sxs-lookup"><span data-stu-id="1c484-170">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="1c484-171">Первый токен в исходном файле получает все начальные элементы trivia, а последняя последовательность trivia в файле присоединяется к токену конца файла, который в противном случае имеет нулевую ширину.</span><span class="sxs-lookup"><span data-stu-id="1c484-171">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="1c484-172">В отличие от синтаксических узлов и токенов элементы syntax trivia не имеют родительских элементов.</span><span class="sxs-lookup"><span data-stu-id="1c484-172">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="1c484-173">Однако, так как они являются частью дерева и каждый из них сопоставлен с одним токеном, к соответствующему токену можно получить доступ с помощью свойства <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1c484-173">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="1c484-174">Диапазоны</span><span class="sxs-lookup"><span data-stu-id="1c484-174">Spans</span></span>

<span data-ttu-id="1c484-175">Каждому узлу, токену или элементу trivia известно его место в тексте исходного кода и число символов, из которых он состоит.</span><span class="sxs-lookup"><span data-stu-id="1c484-175">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="1c484-176">Положение в тексте представлено в виде 32-разрядного целого числа, являющегося отсчитываемым от нуля индексом `char`.</span><span class="sxs-lookup"><span data-stu-id="1c484-176">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="1c484-177">Объект <xref:Microsoft.CodeAnalysis.Text.TextSpan> обозначает начальное положение и количество символов, представленные в виде целых чисел.</span><span class="sxs-lookup"><span data-stu-id="1c484-177">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="1c484-178">Если <xref:Microsoft.CodeAnalysis.Text.TextSpan> имеет нулевую длину, он обозначает расположение между двумя символами.</span><span class="sxs-lookup"><span data-stu-id="1c484-178">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="1c484-179">У каждого узла есть два свойства <xref:Microsoft.CodeAnalysis.Text.TextSpan>: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> и <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="1c484-179">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="1c484-180">Свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> соответствует текстовому диапазону от начала первого токена в поддереве узла до конца последнего токена.</span><span class="sxs-lookup"><span data-stu-id="1c484-180">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node's subtree to the end of the last token.</span></span> <span data-ttu-id="1c484-181">Этот диапазон не включает в себя никакие начальные или конечные элементы trivia.</span><span class="sxs-lookup"><span data-stu-id="1c484-181">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="1c484-182">Свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> является текстовым диапазоном, включающим в себя обычный диапазон узла, а также диапазон любых начальных или конечных элементов trivia.</span><span class="sxs-lookup"><span data-stu-id="1c484-182">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node's normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="1c484-183">Пример:</span><span class="sxs-lookup"><span data-stu-id="1c484-183">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="1c484-184">Узел оператора внутри блока имеет диапазон, обозначаемый отдельными вертикальными чертами (|).</span><span class="sxs-lookup"><span data-stu-id="1c484-184">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="1c484-185">Он включает символы `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="1c484-185">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="1c484-186">Полный диапазон обозначается двойными вертикальными чертами (||).</span><span class="sxs-lookup"><span data-stu-id="1c484-186">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="1c484-187">Он содержит те же символы, что и обычный диапазон, а также символы, связанные с начальными или конечными элементами trivia.</span><span class="sxs-lookup"><span data-stu-id="1c484-187">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="1c484-188">Типы</span><span class="sxs-lookup"><span data-stu-id="1c484-188">Kinds</span></span>

<span data-ttu-id="1c484-189">Каждый узел, токен или элемент trivia имеет свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> типа <xref:System.Int32?displayProperty=nameWithType>, определяющее конкретный представленный элемент синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="1c484-189">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="1c484-190">Это значение можно привести к перечислению определенного языка.</span><span class="sxs-lookup"><span data-stu-id="1c484-190">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="1c484-191">Каждый язык, C# или Visual Basic имеет одно перечисление `SyntaxKind` (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> и <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType> соответственно), содержащее все возможные узлы, токены и другие элементы грамматики.</span><span class="sxs-lookup"><span data-stu-id="1c484-191">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="1c484-192">Это преобразование может выполняться автоматически с помощью методов расширения <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> или <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1c484-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="1c484-193">Свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> позволяет легко устранить неоднозначность типов синтаксических узлов, которые используют один класс узлов.</span><span class="sxs-lookup"><span data-stu-id="1c484-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="1c484-194">Для токенов и элементов trivia это свойство является единственным способом отличить один тип элемента от другого.</span><span class="sxs-lookup"><span data-stu-id="1c484-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="1c484-195">Например, один класс <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> имеет дочерние элементы <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="1c484-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="1c484-196">Свойство <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> позволяет определить, имеет ли этот синтаксический узел тип <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> или <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression>.</span><span class="sxs-lookup"><span data-stu-id="1c484-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

> [!TIP]
> <span data-ttu-id="1c484-197">Рекомендуется проверять типы с помощью методов расширения <xref:Microsoft.CodeAnalysis.CSharpExtensions.IsKind%2A> (для C#) или <xref:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind%2A> (для VB).</span><span class="sxs-lookup"><span data-stu-id="1c484-197">It's recommended to check kinds using <xref:Microsoft.CodeAnalysis.CSharpExtensions.IsKind%2A> (for C#) or <xref:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind%2A> (for VB) extension methods.</span></span>

## <a name="errors"></a><span data-ttu-id="1c484-198">Ошибки</span><span class="sxs-lookup"><span data-stu-id="1c484-198">Errors</span></span>

<span data-ttu-id="1c484-199">Даже если текст исходного кода содержит синтаксические ошибки, предоставляется полное дерево синтаксиса, которое обеспечивает круговой путь до источника.</span><span class="sxs-lookup"><span data-stu-id="1c484-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="1c484-200">Когда средство синтаксического анализа обнаруживает код, который не соответствует заданному синтаксису языка, для создания дерева синтаксиса используется один из двух способов.</span><span class="sxs-lookup"><span data-stu-id="1c484-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree:</span></span>

- <span data-ttu-id="1c484-201">Если средство синтаксического анализа ожидает определенный тип токена, но не находит его, оно может добавить отсутствующий токен в дерево синтаксиса в том расположении, где он ожидался.</span><span class="sxs-lookup"><span data-stu-id="1c484-201">If the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="1c484-202">Отсутствующий токен представляет фактический ожидаемый токен, однако он имеет пустой диапазон, а его свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1c484-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

- <span data-ttu-id="1c484-203">Средство синтаксического анализа может пропускать токены, пока не найдет такой, с которого может продолжить анализ.</span><span class="sxs-lookup"><span data-stu-id="1c484-203">The parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="1c484-204">В этом случае пропущенные токены добавляются в виде узла trivia типа <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="1c484-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
