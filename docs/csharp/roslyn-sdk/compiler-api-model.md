---
title: Концепции пакета SDK для .NET Compiler Platform и объектная модель
description: Этот обзор содержит сведения, необходимые для эффективной работы с пакетом SDK компилятора .NET. Вы узнаете о слоях API, основных используемых типах и общей объектной модели.
ms.date: 07/13/2020
ms.custom: mvc
ms.openlocfilehash: f4b2163c3bf8824b6ad93f0b144a6b02d870f50a
ms.sourcegitcommit: 8299abfbd5c49b596d61f1e4d09bc6b8ba055b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/27/2021
ms.locfileid: "98899169"
---
# <a name="understand-the-net-compiler-platform-sdk-model"></a><span data-ttu-id="2b782-104">Общие сведения о модели пакета SDK для .NET Compiler Platform</span><span class="sxs-lookup"><span data-stu-id="2b782-104">Understand the .NET Compiler Platform SDK model</span></span>

<span data-ttu-id="2b782-105">Компиляторы обрабатывают код, который вы пишете, следуя структурированным правилам, которые часто отличаются от того, как читают и воспринимают код люди.</span><span class="sxs-lookup"><span data-stu-id="2b782-105">Compilers process the code you write following structured rules that often differ from the way humans read and understand code.</span></span> <span data-ttu-id="2b782-106">Понимание принципов работы модели, используемой компиляторами, важно для изучения API, используемых при создании средств на основе Roslyn.</span><span class="sxs-lookup"><span data-stu-id="2b782-106">A basic understanding of the model used by compilers is essential to understanding the APIs you use when building Roslyn-based tools.</span></span>

## <a name="compiler-pipeline-functional-areas"></a><span data-ttu-id="2b782-107">Функциональные области конвейера компилятора</span><span class="sxs-lookup"><span data-stu-id="2b782-107">Compiler pipeline functional areas</span></span>

<span data-ttu-id="2b782-108">Пакет SDK для .NET Compiler Platform реализует функции анализа кода в компиляторах C# и Visual Basic, предоставляя слой API, отражающий традиционный конвейер компилятора.</span><span class="sxs-lookup"><span data-stu-id="2b782-108">The .NET Compiler Platform SDK exposes the C# and Visual Basic compilers' code analysis to you as a consumer by providing an API layer that mirrors a traditional compiler pipeline.</span></span>

![Этапы обработки исходного кода на конвейере компилятора для получения объектного кода](media/compiler-api-model/compiler-pipeline.png)

<span data-ttu-id="2b782-110">Каждый этап конвейера — это отдельный компонент.</span><span class="sxs-lookup"><span data-stu-id="2b782-110">Each phase of this pipeline is a separate component.</span></span> <span data-ttu-id="2b782-111">Сначала на этапе синтаксического анализа выполняется расстановка токенов и анализ текста исходного кода с учетом синтаксиса, а затем и грамматики языка.</span><span class="sxs-lookup"><span data-stu-id="2b782-111">First, the parse phase tokenizes and parses source text into syntax that follows the language grammar.</span></span> <span data-ttu-id="2b782-112">Потом на этапе объявления анализируется источник и импортированные метаданные для формирования именованных символов.</span><span class="sxs-lookup"><span data-stu-id="2b782-112">Second, the declaration phase analyzes source and imported metadata to form named symbols.</span></span> <span data-ttu-id="2b782-113">Далее на этапе привязки идентификаторы в коде сопоставляются с символами.</span><span class="sxs-lookup"><span data-stu-id="2b782-113">Next, the bind phase matches identifiers in the code to symbols.</span></span> <span data-ttu-id="2b782-114">Наконец, на этапе порождения создается сборка со всеми сведениями, сформированными компилятором.</span><span class="sxs-lookup"><span data-stu-id="2b782-114">Finally, the emit phase emits an assembly with all the information built up by the compiler.</span></span>

![API конвейера компилятора предоставляет доступ к каждому шагу, который является частью конвейера компилятора.](media/compiler-api-model/compiler-pipeline-api.png)

<span data-ttu-id="2b782-116">В соответствии с каждым из этих этапов пакет SDK для .NET Compiler Platform предоставляет объектную модель, обеспечивающую доступ к информации на этом этапе.</span><span class="sxs-lookup"><span data-stu-id="2b782-116">Corresponding to each of those phases, the .NET Compiler Platform SDK exposes an object model that allows access to the information at that phase.</span></span> <span data-ttu-id="2b782-117">Этап анализа предоставляет дерево синтаксиса, этап объявления предоставляет таблицу иерархических символов, этап привязки предоставляет результат семантического анализа компилятора, а этап порождения — это API, создающий коды байтов IL.</span><span class="sxs-lookup"><span data-stu-id="2b782-117">The parsing phase exposes a syntax tree, the declaration phase exposes a hierarchical symbol table, the binding phase exposes the result of the compiler's semantic analysis, and the emit phase is an API that produces IL byte codes.</span></span>

![Языковые службы, доступные из API компилятора на каждом этапе конвейера компилятора](media/compiler-api-model/compiler-pipeline-lang-svc.png)

<span data-ttu-id="2b782-119">Каждой компилятор сочетает в себе эти компоненты, образуя единый процесс.</span><span class="sxs-lookup"><span data-stu-id="2b782-119">Each compiler combines these components together as a single end-to-end whole.</span></span>

<span data-ttu-id="2b782-120">Эти API также используются в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="2b782-120">These APIs are the same ones used by Visual Studio.</span></span> <span data-ttu-id="2b782-121">Например, функции структурирования и форматирования кода используют деревья синтаксиса, **обозреватель объектов** и функции навигации — таблицу символов, рефакторинг и операции **Перейти к определению** — семантическую модель, а операция **Изменить и продолжить** использует их все, включая API порождения.</span><span class="sxs-lookup"><span data-stu-id="2b782-121">For instance, the code outlining and formatting features use the syntax trees, the **Object Browser**, and navigation features use the symbol table, refactorings and **Go to Definition** use the semantic model, and **Edit and Continue** uses all of these, including the Emit API.</span></span>

## <a name="api-layers"></a><span data-ttu-id="2b782-122">Слои API</span><span class="sxs-lookup"><span data-stu-id="2b782-122">API layers</span></span>

<span data-ttu-id="2b782-123">Пакет SDK компилятора .NET состоит из нескольких основных слоев API: API компилятора, API диагностики, API скриптов и API рабочих областей.</span><span class="sxs-lookup"><span data-stu-id="2b782-123">The .NET compiler SDK consists of several layers of APIs: compiler APIs, diagnostic APIs, scripting APIs, and workspaces APIs.</span></span>

### <a name="compiler-apis"></a><span data-ttu-id="2b782-124">API компилятора</span><span class="sxs-lookup"><span data-stu-id="2b782-124">Compiler APIs</span></span>

<span data-ttu-id="2b782-125">Слой компилятора содержит объектные модели, которые соответствуют сведениям, представляемым на каждом этапе конвейера компилятора, как синтаксическим, так и семантическим.</span><span class="sxs-lookup"><span data-stu-id="2b782-125">The compiler layer contains the object models that correspond to information exposed at each phase of the compiler pipeline, both syntactic and semantic.</span></span> <span data-ttu-id="2b782-126">Слой компилятора также содержит неизменяемый моментальный снимок однократного вызова компилятора, включая ссылки на сборки, параметры компилятора и файлы исходного кода.</span><span class="sxs-lookup"><span data-stu-id="2b782-126">The compiler layer also contains an immutable snapshot of a single invocation of a compiler, including assembly references, compiler options, and source code files.</span></span> <span data-ttu-id="2b782-127">Существует два отдельных API, представляющих язык C# и Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2b782-127">There are two distinct APIs that represent the C# language and the Visual Basic language.</span></span> <span data-ttu-id="2b782-128">Эти два API похожи по форме, но для обеспечения высокой точности привязаны к конкретному языку.</span><span class="sxs-lookup"><span data-stu-id="2b782-128">The two APIs are similar in shape but tailored for high-fidelity to each individual language.</span></span> <span data-ttu-id="2b782-129">Этот слой не имеет зависимостей от компонентов Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="2b782-129">This layer has no dependencies on Visual Studio components.</span></span>

### <a name="diagnostic-apis"></a><span data-ttu-id="2b782-130">API диагностики</span><span class="sxs-lookup"><span data-stu-id="2b782-130">Diagnostic APIs</span></span>

<span data-ttu-id="2b782-131">В процессе анализа компилятор может создать набор данных диагностики, охватывающий все — от синтаксиса, семантики и явных ошибок присваивания до различных предупреждений и информационных диагностических сообщений.</span><span class="sxs-lookup"><span data-stu-id="2b782-131">As part of its analysis, the compiler may produce a set of diagnostics covering everything from syntax, semantic, and definite assignment errors to various warnings and informational diagnostics.</span></span> <span data-ttu-id="2b782-132">Слой API компилятора предоставляет диагностику посредством расширяемого API, который разрешает подключать пользовательские анализаторы к процессу компиляции.</span><span class="sxs-lookup"><span data-stu-id="2b782-132">The Compiler API layer exposes diagnostics through an extensible API that allows user-defined analyzers to be plugged into the compilation process.</span></span> <span data-ttu-id="2b782-133">Она позволяет создавать заданные пользователем диагностические данные, например, формируемые такими программами, как StyleCop, параллельно с диагностическими данными, определенными компилятором.</span><span class="sxs-lookup"><span data-stu-id="2b782-133">It allows user-defined diagnostics, such as those produced by tools like StyleCop, to be produced alongside compiler-defined diagnostics.</span></span> <span data-ttu-id="2b782-134">Такое формирование данных диагностики дает преимущество естественной интеграции со средствами, такими как MSBuild и Visual Studio, которые зависят от диагностики при применении таких процедур, как прерывание сборки на основе политики, отображение динамических волнистых линий в редакторе и предложение исправлений кода.</span><span class="sxs-lookup"><span data-stu-id="2b782-134">Producing diagnostics in this way has the benefit of integrating naturally with tools such as MSBuild and Visual Studio, which depend on diagnostics for experiences such as halting a build based on policy and showing live squiggles in the editor and suggesting code fixes.</span></span>

### <a name="scripting-apis"></a><span data-ttu-id="2b782-135">API скриптов</span><span class="sxs-lookup"><span data-stu-id="2b782-135">Scripting APIs</span></span>

<span data-ttu-id="2b782-136">API размещения и скриптов являются частью слоя компилятора.</span><span class="sxs-lookup"><span data-stu-id="2b782-136">Hosting and scripting APIs are part of the compiler layer.</span></span> <span data-ttu-id="2b782-137">Их можно использовать для выполнения фрагментов кода и накопления контекста выполнения во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="2b782-137">You can use them for executing code snippets and accumulating a runtime execution context.</span></span>
<span data-ttu-id="2b782-138">Интерактивная среда REPL (read-evaluate-print loop) C# использует эти API.</span><span class="sxs-lookup"><span data-stu-id="2b782-138">The C# interactive REPL (Read-Evaluate-Print Loop) uses these APIs.</span></span> <span data-ttu-id="2b782-139">REPL позволяет использовать C# в качестве скриптового языка C#, выполняя код в интерактивном режиме по мере его написания.</span><span class="sxs-lookup"><span data-stu-id="2b782-139">The REPL enables you to use C# as a scripting language, executing the code interactively as you write it.</span></span>

### <a name="workspaces-apis"></a><span data-ttu-id="2b782-140">API рабочих областей</span><span class="sxs-lookup"><span data-stu-id="2b782-140">Workspaces APIs</span></span>

<span data-ttu-id="2b782-141">Слой рабочих областей содержит соответствующий API, который является отправной точкой для анализа кода и рефакторинга в рамках целых решений.</span><span class="sxs-lookup"><span data-stu-id="2b782-141">The Workspaces layer contains the Workspace API, which is the starting point for doing code analysis and refactoring over entire solutions.</span></span> <span data-ttu-id="2b782-142">Он помогает упорядочить всю информацию о проектах в решении в рамках одной объектной модели, предоставляя вам прямой доступ к объектным моделям слоя компилятора без необходимости анализировать файлы, настраивать параметры или управлять зависимостями между проектами.</span><span class="sxs-lookup"><span data-stu-id="2b782-142">It assists you in organizing all the information about the projects in a solution into a single object model, offering you direct access to the compiler layer object models without needing to parse files, configure options, or manage project-to-project dependencies.</span></span>

<span data-ttu-id="2b782-143">Кроме того, слой рабочих областей предоставляет набор API, используемый реализацией средств анализа кода и рефакторинга, которые работают в среде размещения, таких как Visual Studio IDE.</span><span class="sxs-lookup"><span data-stu-id="2b782-143">In addition, the Workspaces layer surfaces a set of APIs used when implementing code analysis and refactoring tools that function within a host environment like the Visual Studio IDE.</span></span> <span data-ttu-id="2b782-144">В качестве примеров можно привести API "Найти все ссылки", "Форматирование" и "Создание кода".</span><span class="sxs-lookup"><span data-stu-id="2b782-144">Examples include the Find All References, Formatting, and Code Generation APIs.</span></span>

<span data-ttu-id="2b782-145">Этот слой не имеет зависимостей от компонентов Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="2b782-145">This layer has no dependencies on Visual Studio components.</span></span>
